<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Serverless 智能化应用</title>
    <link href="/2024/03/05/serverless_ai/"/>
    <url>/2024/03/05/serverless_ai/</url>
    
    <content type="html"><![CDATA[<h1 id="Serverless-智能化应用"><a href="#Serverless-智能化应用" class="headerlink" title="Serverless 智能化应用"></a>Serverless 智能化应用</h1><h1 id="研究问题"><a href="#研究问题" class="headerlink" title="研究问题"></a>研究问题</h1><ul><li><p>底层系统资源的配置（GPU，内存大小配置等）智能适应 or 人工设定</p></li><li><p>有状态函数的快速存储机制</p></li><li><p>容错</p><ul><li>执行顺序：多个无状态函数可能会乱序执行，导致结果也是乱序</li><li>执行状态：有状态函数的执行可能会断掉，需要能够恢复</li></ul></li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><h2 id="Cirrus-a-Serverless-Framework-for-End-to-end-ML-Workflow"><a href="#Cirrus-a-Serverless-Framework-for-End-to-end-ML-Workflow" class="headerlink" title="Cirrus: a Serverless Framework for End-to-end ML Workflow"></a><a href="https://dl.acm.org/doi/abs/10.1145/3357223.3362711">Cirrus: a Serverless Framework for End-to-end ML Workflow</a></h2><p>代码仓库：<a href="https://github.com/ucbrise/cirrus">https://github.com/ucbrise/cirrus</a></p><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li><p>解决 ML 过程资源配置和管理的问题</p><ul><li>传统的 <code>workflow</code> 拥有多个阶段，每一个阶段的计算都是异构的</li><li>计算的异构使得机器学习用户很难正确配置和管理资源，并且在实践中，这会构成重大负担，经常导致过度配置并损害用户生产力。</li></ul></li><li><p>Serverless 可以很好的管理资源</p><ul><li>但是很难适应 Serverless</li></ul></li><li><p><code>Cirrus</code> 通过 Serverless 的框架对 ML 做资源的适配管理</p><ul><li>轻量级的工作运行时，为 ML 人员找到最适合的资源配置</li><li>节省了配置大量内存或存储的成本<ul><li>(a) 来自远程存储的流式训练小批量数据；</li><li>(b) 重新设计分布式训练算法以在无服务器环境中稳健运行</li></ul></li><li>采用无状态的 worker 架构，使系统能够有效地处理频繁的 worker 离开和到达作为预期行为。</li></ul></li></ul><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li><p>ML Workflow 带来两个问题</p><ul><li>过度配置：如果使用虚拟机做资源的配置，配置的复杂性就会导致过度配置</li><li>资源管理：管理的复杂性降低了交互式和迭代用例</li></ul></li><li><p>Serverless 本身的挑战</p><ul><li>内存以及存储过小：利用无服务器计算的主要挑战是与 lambda 函数相关的本地资源限制（内存、CPU、存储、网络）非常小</li><li>低带宽以及缺少 P2P 通信：最新的 Lambda 也只有 60MB 的带宽；缺少通信策略，用于数据中心机器学习的常见通信策略，例如树形结构或环形结构的 AllReduce 通信，在此类环境中受到限制</li><li>启动时间短暂并且不可预测：Lambda 函数的生命周期很短，并且其启动时间变化很大。这意味着在训练期间，lambda 会在不可预测的时间开始，并可能在训练中间结束。这需要 lambda 的 ML 运行时能够容忍工作人员的频繁离开和到达。</li><li>缺少快速共享存储的功能：由于 lambda 函数彼此不能直接通信，因此需要快速的共享存储。但是 ML 训练对数据的性能要求非常高，不能有太大的延时</li></ul></li></ul><h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><h4 id="系统架构图"><a href="#系统架构图" class="headerlink" title="系统架构图"></a>系统架构图</h4><p><img src="/../assets/serverless_ai/T6RKbWlZ9o53x3xfiy6chhkXn7g.png"></p><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><ul><li><p>Python 前端：提供了一个底层抽象系统资源的高级接口</p><ul><li>预处理模块：该子模块允许不同类型的数据集转换：最小-最大缩放、标准化和特征哈希。</li><li>训练模块：可以使用随机梯度下降来训练的 ML 模型。</li><li>超参数优化：允许用户对给定的参数集运行网格搜索。</li></ul></li><li><p>客户端后端：解析训练数据并将其加载到 S3，在 lambda 上启动 Cirrus 工作程序，管理分布式数据存储，跟踪计算进度，并在计算完成后将结果返回到 Python 前端。</p></li><li><p>工作运行时：Cirrus 提供了一个运行时，它封装了系统支持的不同计算之间共享的所有函数</p></li><li><p>分布式数据存储：</p><ul><li>低延迟：将数据存储部署在云虚拟机中</li><li>可扩展：Cirrus 包括以下机制：(1) 分片存储、(2) 高度多线程、(3) 数据压缩、(4) 梯度过滤器和 (5) 异步通信。</li><li>强接口</li></ul></li></ul><h4 id="端到端的-ML-阶段"><a href="#端到端的-ML-阶段" class="headerlink" title="端到端的 ML 阶段"></a>端到端的 ML 阶段</h4><ul><li><p>数据加载与预处理</p><ul><li>假设数据已经被全局存储（例如 S3）Cirrus 将其转为二进制数据</li><li>使用 Map-Reduce 模式。</li></ul></li><li><p>模型训练</p><ul><li>分布式 SGD 算法</li><li>每个 <code>worker</code> 运行 Lambda 函数并负责迭代计算梯度步骤。每个梯度计算都需要两个输入：一个小批量和最新的模型</li><li>对于每次迭代，每个工作人员都会计算一个新的梯度。然后将该梯度异步发送到数据存储 (send_gradient_X ) 以更新模型。</li></ul></li><li><p>超参数优化</p><ul><li>典型的做法是在多维参数空间上执行网格搜索。通常让网格搜索完全运行完成并对结果进行后处理以找到最佳配置（过度配置）</li><li>随着时间的推移，Cirrus 通过提供超参数搜索仪表板来消除这种过度配置的情况</li><li>因此，Cirrus 提供 (a) 用于启动超参数搜索的 API 和执行后端，(b) 用于监控模型精度收敛的仪表板，(c) 终止单独调整实验并节省超额配置成本的能力。</li></ul></li></ul><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="Python-前端"><a href="#Python-前端" class="headerlink" title="Python 前端"></a>Python 前端</h4><ul><li>抽象了有关开发者的细节</li><li>通过 API 参数覆盖内部配置参数</li></ul><h4 id="Client-后端"><a href="#Client-后端" class="headerlink" title="Client 后端"></a>Client 后端</h4><ul><li><p>将前端的算法部署到 Lambda 上并抽象了管理</p><ul><li>内部保存了与 Lambda 函数的连接列表</li></ul></li><li><p>使用线程池响应请求</p><ul><li>Lambda API 的特殊性</li></ul></li></ul><h4 id="分布式数据存储"><a href="#分布式数据存储" class="headerlink" title="分布式数据存储"></a>分布式数据存储</h4><ul><li><p>多线程服务器，将任务分配给多个核心</p><ul><li>目的：高效地更新模型</li></ul></li><li><p>对传入&#x2F;传出存储的梯度和模型实施数据压缩</p><ul><li>目的：减少网络带来的瓶颈</li></ul></li><li><p>通过发送和接收稀疏梯度和模型数据结构来优化通信</p></li></ul><h4 id="Worker-运行时"><a href="#Worker-运行时" class="headerlink" title="Worker 运行时"></a>Worker 运行时</h4><p><img src="/../assets/serverless_ai/EIpDbh2kooFxcOxq9BMcZ2QUnXV.png"></p><ul><li>ML 计算的通用抽象</li><li>用于访问训练数据、参数模型和中间结果的数据原语。</li></ul><h2 id="Ray-A-Distributed-Framework-for-Emerging-AI-Applications"><a href="#Ray-A-Distributed-Framework-for-Emerging-AI-Applications" class="headerlink" title="Ray: A Distributed Framework for Emerging AI Applications"></a><a href="https://www.usenix.org/conference/osdi18/presentation/moritz">Ray: A Distributed Framework for Emerging AI Applications</a></h2><h3 id="解决问题-1"><a href="#解决问题-1" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li><p>需求：下一代的 AI 需要持续与环境交互，对性能和复杂性有要求</p><ul><li>必须支持细粒度计算</li><li>支持时间和资源的合理使用的异构性</li><li>必须支持动态执行，因为模拟或与环境交互的结果可能会改变未来的计算</li></ul></li><li><p>贡献：Ray，一个通用集群计算框架，支持 RL 应用程序的模拟、训练和服务</p><ul><li>该框架统一了新兴 RL 应用程序的训练、模拟和服务必要组件</li><li>抽象任务并行以及 Actor 计算</li><li>控制状态存储在分片元数据存储中，所有其他系统组件都是无状态的。</li><li>自下而上的分布式调度策略</li></ul></li></ul><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li><p>针对需求</p><ul><li>细粒度、异构计算<ul><li>计算时间可能几秒钟到几小时</li><li>硬件资源可能也不一样</li></ul></li><li>灵活的计算模型<ul><li>无状态：无状态计算可以在系统中的任何节点上执行，这使得在需要时可以轻松实现负载平衡和计算到数据的移动<ul><li>适合细粒度模拟和数据处理</li></ul></li><li>有状态：状态计算非常适合实现参数服务器、对 GPU 支持的数据执行重复计算或运行不公开其状态的第三方模拟器</li></ul></li><li>动态执行<ul><li>计算完成的顺序并不总是事先知道（例如，模拟完成的顺序），并且计算的结果可以决定未来的计算</li></ul></li></ul></li><li><p>对要实现的目标</p><ul><li>要每秒处理数百万个任务</li><li>集成现有的模拟器以及机器学习框架</li></ul></li></ul><h3 id="编程与计算模型"><a href="#编程与计算模型" class="headerlink" title="编程与计算模型"></a>编程与计算模型</h3><h4 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h4><ul><li><p><code>Tasks</code>：表示在无状态工作线程上执行远程函数</p><ul><li>并行：当调用远程函数时，会立即返回表示任务结果的 future</li><li>协作：可以使用 ray.get() 检索 Future，并将其作为参数传递给其他远程函数</li><li>无状态：对不可变对象进行操作，具有幂等性，具备容错能力</li></ul></li><li><p><code>Actor</code>：表示有状态的计算</p><ul><li><code>handle</code>：可以被传递给其他的 <code>Actor</code>，便于远程调用</li></ul></li></ul><p><img src="/../assets/serverless_ai/IzQgbNQ7joYN7Hxcc5tcVVCEnNg.png"></p><ul><li>为了处理具有异构持续时间的并发任务，引入了 ray.wait()，它等待前 k 个可用结果，而不是像 ray.get() 那样等待所有结果。</li><li>为了处理资源异构任务，使开发人员能够指定资源需求，以便 Ray 调度器能够有效地管理资源。</li><li>为了提高灵活性，启用<strong>嵌套远程函数</strong>，这意味着远程函数可以调用其他远程函数。这对于实现高可扩展性也至关重要，因为它允许多个进程以分布式方式调用远程函数。</li></ul><h4 id="计算模型"><a href="#计算模型" class="headerlink" title="计算模型"></a>计算模型</h4><ul><li><p>任务图计算：输入满足条件时自动触发</p><ul><li>两种节点类型<ul><li>数据节点</li><li>任务节点</li></ul></li><li>两种边<ul><li>数据边：捕捉数据节点和任务节点之间的依赖关系<ul><li>若 D 是 T 的输出，那么从 T 到 D 就有一条连边</li></ul></li><li>控制边：捕捉两个有调用关系的任务节点之间的计算依赖关系<ul><li>若 T1 调用 T2，那么 T1 到 T2 有一条边</li></ul></li></ul></li></ul></li><li><p>Actor</p><ul><li>新增状态边<ul><li>若 Mj 方法在 Mi 方法之后，那么 Mi 到 Mj 有一条边</li><li>所有对一个 Actor 的方法的调用顺序通过状态边连接</li></ul></li></ul></li><li><p>有状态边帮助我们将参与者嵌入到无状态任务图中，因为它们捕获共享参与者内部状态的连续方法调用之间的隐式数据依赖关系</p></li></ul><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><ul><li>应用层：实现 API</li><li>系统层：提供高拓展性以及容错性</li></ul><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><ul><li><p><code>Driver</code>：运行用户程序的进程</p></li><li><p><code>Worker</code>：一个调用远程函数或 Task 的无状态进程</p><ul><li>由系统层分配任务</li><li>当远程函数被声明时，函数被分配到所有的 <code>Worker</code></li></ul></li><li><p><code>Actor</code>：有状态进程，在调用时仅执行他所公开的方法</p><ul><li><code>Actor</code> 必须被显式实例化</li><li>通过之前方法的执行结果序列化地执行方法</li></ul></li></ul><h4 id="系统层"><a href="#系统层" class="headerlink" title="系统层"></a>系统层</h4><p><img src="/../assets/serverless_ai/TRtMbePDxoNIBBxigoEcxkubnxh.png"></p><h5 id="全局控制存储（GCS）：维护系统的控制状态"><a href="#全局控制存储（GCS）：维护系统的控制状态" class="headerlink" title="全局控制存储（GCS）：维护系统的控制状态"></a>全局控制存储（GCS）：维护系统的控制状态</h5><ul><li><p>具有发布-订阅的键值存储</p><ul><li>使用分片来实现扩展</li><li>使用每个分片链复制来提供容错能力</li></ul></li><li><p>容错能力</p><ul><li>需要维护沿袭信息：持久沿袭信息组件与其他组件分离，每个组件独立扩展</li></ul></li><li><p>保持低延迟</p><ul><li>最大限度的减少任务调度的开销</li><li>任务分配与任务调度分离：对象元数据存储在 GCS 中而不是调度程序中</li></ul></li><li><p>使系统中的每个其他组件都是无状态的</p></li></ul><h5 id="自下而上的分部署调度器：两级分层调度器"><a href="#自下而上的分部署调度器：两级分层调度器" class="headerlink" title="自下而上的分部署调度器：两级分层调度器"></a>自下而上的分部署调度器：两级分层调度器</h5><ul><li><p>全局调度器</p><ul><li>考虑每个节点的负载和任务的约束来做出调度决策</li><li>选择提供最短估计等待时间的节点</li><li>通过心跳获取每个节点的队列大小和节点资源可用性，以及来自 GCS 的任务输入的位置及其大小。</li><li>如果全局调度程序成为瓶颈，可以通过 GCS 实例化更多共享相同信息的副本</li></ul></li><li><p>每个节点本地调度器</p><ul><li>每个节点创建的任务首先通过本地调度器</li><li>本地调度器在本地调度程序，直到节点过载</li><li>当本地调度器不想管了，就交给全局调度器</li></ul></li></ul><p><img src="/../assets/serverless_ai/QU23b2xyEogFT1xauHzcpLb8nyc.png"></p><h5 id="内存中分布式对象存储"><a href="#内存中分布式对象存储" class="headerlink" title="内存中分布式对象存储"></a>内存中分布式对象存储</h5><p>在每个节点上，通过共享内存实现对象存储。这允许在同一节点上运行的任务之间进行零拷贝数据共享。作为数据格式，使用 Apache Arrow</p><ul><li><p>对象存储：</p><ul><li>如果任务的输入不是本地的，则输入会在执行之前复制到本地对象存储。</li><li>此外，任务将其输出写入本地对象存储</li></ul></li><li><p>低延迟</p><ul><li>将整个对象保持在内存中，通过 LRU 机制写入磁盘</li></ul></li><li><p>容错</p><ul><li>通过沿袭重新执行来恢复任何所需的对象。</li><li>在初始执行时，GCS 存储的沿袭信息追踪着有状态的 Actor 以及无状态的 Tasks</li><li></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Serverless</tag>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Serverless 函数编排</title>
    <link href="/2024/03/02/serverless_orchestration/"/>
    <url>/2024/03/02/serverless_orchestration/</url>
    
    <content type="html"><![CDATA[<h1 id="Serverless-函数编排"><a href="#Serverless-函数编排" class="headerlink" title="Serverless 函数编排"></a>Serverless 函数编排</h1><h1 id="系统目标"><a href="#系统目标" class="headerlink" title="系统目标"></a>系统目标</h1><ul><li>构建一套基于事件驱动的有限状态机模型的函数编排系统，可以编排不同云平台上的 Serverless 函数<ul><li>异构平台的标准化<ul><li>支持不同云平台函数的运行时</li><li>支持不同云平台的事件处理</li></ul></li><li>高效执行<ul><li>基于事件驱动的有限状态机模型</li><li>函数并行度优化</li></ul></li><li>简单部署<ul><li>前端：函数式编程</li><li>中端：Workflow 静态图</li><li>后端：运行时组件</li></ul></li></ul></li></ul><h1 id="模型构建"><a href="#模型构建" class="headerlink" title="模型构建"></a>模型构建</h1><h2 id="有限状态机模型"><a href="#有限状态机模型" class="headerlink" title="有限状态机模型"></a>有限状态机模型</h2><p>使用有限状态机管理触发器</p><h2 id="事件抽象"><a href="#事件抽象" class="headerlink" title="事件抽象"></a>事件抽象</h2><p>事件作为外部输入关系触发器</p><h2 id="函数流"><a href="#函数流" class="headerlink" title="函数流"></a>函数流</h2><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><h2 id="Triggerflow-Trigger-based-orchestration-of-serverless-workflows"><a href="#Triggerflow-Trigger-based-orchestration-of-serverless-workflows" class="headerlink" title="Triggerflow: Trigger-based orchestration of serverless workflows"></a><a href="https://www.sciencedirect.com/science/article/pii/S0167739X21001989">Triggerflow: Trigger-based orchestration of serverless workflows</a></h2><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>现有的云编排系统要么专注于短期运行的工作流程，要么为同步大规模并行作业带来相当大的开销。没有能够对自定义工作流进行可扩展拦截以及优化的开放系统</p><ul><li>短期运行：IBM Composer、Amazon Step Functions Express Workflows</li><li>大开销：Azure Durable Functions、Amazon Step Functions</li></ul><h3 id="工作难点"><a href="#工作难点" class="headerlink" title="工作难点"></a>工作难点</h3><ul><li><p>通过 CEP 规则执行业务流程</p><ul><li>CEP：Complex Event Processing</li></ul></li><li><p>使用触发器做服务工作流编排是可能的但是往往不理想</p><ul><li>有必要为每个步骤创建不同的队列或目录</li><li>触发器不能够一直等到前面多个函数的执行结束</li><li>触发器不适用于错误处理</li></ul></li></ul><h3 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h3><ul><li><p>利用基于内容的发布&#x2F;订阅系统中的复合订阅来提供分散的基于事件的工作流程管理 <a href="https://link.springer.com/chapter/10.1007/11587552_13">link.springer.com</a></p></li><li><p><a href="https://serverlessworkflow.io/">serverlessworkflow.io</a> 该工作提出将工作流声明为 YAML 文件，其中包含要使用的 CloudEvents 概述、无服务器函数的事件驱动调用以及工作流数据管理和控制流逻辑的状态转换。</p><ul><li>定义了一个可以被不同系统解释的抽象定义，从而保证可移植性避免供应商锁定</li></ul></li><li><p>当下的 Serverless 编排系统大多数依赖于集中式的服务器资源（虚拟机）或者是专有资源</p><ul><li>坏处<ul><li>不能将资源占有量降为 0</li><li>工作流执行时编排组件持续活跃，工作流执行时间长时造成资源浪费</li></ul></li></ul></li><li><p>IBM Composer 生成一个状态机代表着即将要被执行的 IBM Cloud Functions</p><ul><li>能够表示顺序、条件分支、循环、并行以及任务映射</li><li><code>fork/join</code> 同步阻塞了外部用户提供的 <code>Redis</code> 服务，限制了其对短期运行任务的适用性</li></ul></li><li><p>Amazon Step Functions and Amazon Step Functions Express Workflows 使用 JSON 模型化任务转移、选择、等待、并行、映射，ASF 是一个支持 Workflow 错误容忍服务，ASFE 时用户支撑短时运行的工作负载</p></li><li><p>微软的 Azure Durable Functions（ADF）提出了使用代码生成 Workflows 的方式，使用 <code>async/await</code> 结构，使用事件源重启被挂起的工作流</p><ul><li>不支持映射工作</li><li>只包含了 <code>Task.whenAll</code> 抽象来实现 <code>fork/join</code></li></ul></li><li><p>谷歌云提供了 Google Cloud Workflows 服务。它的工作流包括了一系列的基于逻辑的步骤，逻辑类似于条件或者循环。可以通过对每一个步骤发出一个 HTTP Request 的方式来触发 Google Cloud Function</p><ul><li>不适合用来做广播的并行任务</li></ul></li></ul><h3 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h3><ul><li><p>ECA 模型：Event-Condition-Action, <code>Event Sources</code> and <code>Programmable Conditions</code> and <code>Actions</code></p><ul><li>包含触发器和规则：适合定义表示工作流的有限状态机的状态转移</li></ul></li><li><p>触发器服务</p><ul><li>Workflow: 由 6 元组组成的一个有限状态机<ul><li>输入事件的集合</li><li>上下文变量</li><li>将 Actions 映射到 ECA 模型</li><li>初始状态</li><li>终止状态</li><li>状态转移方程，通过 ECA 触发器转移</li></ul></li><li>Trigger: 可以看作是状态转移方程，由四元组构成<ul><li>事件：驱动云应用的院原子信息。使用 subject 字段匹配事件对应的触发器，使用 type 字段描述事件的类型</li><li>上下文：一个 key-value 的数据结构，包含了触发器运行周期的状态</li><li>条件：由用户定义的决定事件是否匹配行为</li><li>行为：用于异步地触发一个 Serverless 函数</li></ul></li></ul><blockquote><p>触发器的生命周期可以表示如下：</p><ol><li>一个事件由某些事件源产生</li><li>事件被系统消费，激活对应的触发器</li><li>事件由 Condition 函数处理，若结果是正确的，就交由 Action 函数处理</li><li>Action 函数被激活了，就称作该触发器被 fired</li><li>当一个触发器被 fired 的时候，他就可以被 disabled 或者由系统 maintain<ul><li>Mapping Workflows to Triggers：一个工作流可以通过一系列触发器进行映射</li><li>任意工作流抽象都可以通过有限状态机表示，可以被转化为各种各样的触发器，并且通过 TriggerFlow 表示</li><li>Substitution Principle：工作流本身通过初始化和终止遵守操作。工作流可以嵌套</li><li>Dynamic Trigger Interception：</li></ul></li></ol></blockquote></li><li><p>错误容忍：</p><ul><li>事件总线保证事件的至少一次传递<ul><li>事件可以重复无序</li></ul></li><li>通过 CloudEvent 标准为每个事件赋予一个 ID<ul><li>在事件处理阶段，同样 ID 的事件就会丢弃</li></ul></li><li>通过辨别两种事件组合类型来处理无序消息<ul><li>聚合：如计数器。由于消息顺序不会改变最终结果，故不用考虑</li><li>序列：仅仅处理激活序列开头的触发器的事件，其他事件将被延迟，直到启用他们激活的触发器</li></ul></li></ul></li></ul><h2 id="Comparison-of-FaaS-Orchestration-Systems"><a href="#Comparison-of-FaaS-Orchestration-Systems" class="headerlink" title="Comparison of FaaS Orchestration Systems"></a><a href="https://ieeexplore.ieee.org/abstract/document/8605772">Comparison of FaaS Orchestration Systems</a></h2><h3 id="解决问题-1"><a href="#解决问题-1" class="headerlink" title="解决问题"></a>解决问题</h3><p>本文章比较了四种函数编排平台 AWS Lambda, IBM Cloud Functions, Google Cloud Functions,Azure Functions</p><h3 id="相关工作-1"><a href="#相关工作-1" class="headerlink" title="相关工作"></a>相关工作</h3><ul><li><p>IBM Serverless 的三大难题</p><ul><li>函数需要在一个沙箱中进行</li><li>函数组合应该遵循同步调用的替换原则（即组合也应该是一个函数）</li><li>调用不应该重复计费</li></ul></li><li><p>编排函数不需要外部的运行时支持</p><ul><li>两种解决模式<ul><li>使用函数进行编排<ul><li>函数的编排是在一个 Serverless 函数中进行的</li><li>带来双重付费的问题</li></ul></li><li>使用外部的客户端进行编排<ul><li>能够解决双重付费问题</li><li>不能视为函数，违反替换原则</li></ul></li></ul></li></ul></li></ul><h3 id="评估模型"><a href="#评估模型" class="headerlink" title="评估模型"></a>评估模型</h3><ul><li>ST-safeness：符合三难困境的编排服务被称为 STsafe。</li><li>Programming model：编程简单性和编码抽象集，是否提供反射 API 来观察函数组合的当前状态。</li><li>Parallel execution support：并行执行支持</li><li>State management：数据如何从一个函数转移到下一个函数</li><li>Architecture：编排器是客户端调度程序或者是本身就是一个函数，用于事件的响应</li><li>Overhead：鉴于编排服务对函数调度程序的依赖，应针对代表性函数组合（例如链和并行模式）来衡量编排开销的重要性</li><li>Billing model</li></ul><h3 id="评估结果"><a href="#评估结果" class="headerlink" title="评估结果"></a>评估结果</h3><table><thead><tr><th></th><th>ST-safeness</th><th>Programming model</th><th>Parallel execution support</th><th>State management</th><th>Architecture</th><th>Overhead</th></tr></thead><tbody><tr><td>Amazon Step Functions (ASF)</td><td>不满足，因为函数编排不是函数</td><td>- 支持顺序和分支，函数重试以及并行。- 只能静态图- 提供了反射 API 查询状态以及取消执行- 通过 CloudWatch 监控</td><td>支持</td><td>32KB 的限制</td><td>外部编排器</td><td></td></tr><tr><td>IBM Composer</td><td>满足，也是第一个满足的</td><td>- 提供了完整的编排库- 不提供并行的 DSL- 但是可以将函数作为前端接口暴露- 不支持反射 API，只能通过日志</td><td>不支持</td><td>5MB 的状态转移限制</td><td>集成在反应式核心中</td><td>提供了包，支持用户上传包</td></tr><tr><td>Azure Durable Functions (ADF)</td><td>满足</td><td>- 通过 C#代码创建函数流- 提供了反射 API，不仅能获取当前的状态，也能触发事件到一个挂起的函数</td><td>支持</td><td>不限制</td><td>外部编排器</td><td>提供了非常简单的包</td></tr></tbody></table><h2 id="FaaSFlow-enable-efficient-workflow-execution-for-function-as-a-service"><a href="#FaaSFlow-enable-efficient-workflow-execution-for-function-as-a-service" class="headerlink" title="FaaSFlow: enable efficient workflow execution for function-as-a-service"></a><a href="https://dl.acm.org/doi/10.1145/3503222.3507717">FaaSFlow: enable efficient workflow execution for function-as-a-service</a></h2><h3 id="解决问题-2"><a href="#解决问题-2" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>传统的 master-worker 架构性能太差<ul><li>master 的调度模式，通过该模式，功能在 master 节点中触发并分配给工作节点来执行。</li><li>worker 之间的数据移动也会降低吞吐量。</li></ul></li></ul><blockquote><p>These serverless workflow systems usually provide a centralized workflow engine on the master node to manage the workflow execution state and assign function tasks to the worker nodes. We refer to this scheduling pattern as master-side workflow schedule pattern (denoted by MasterSP), as the central workflow engine in the master node determines whether a function task is triggered to run or not<br><img src="/../assets/serverless_workflow/ZlhlbGgQ7oYaSrx0LlycRwvinbg.png"><br>这些无服务器工作流系统通常在主节点上提供集中式工作流引擎来管理工作流执行状态并将功能任务分配给工作节点。我们将这种调度模式称为主端工作流调度模式（记为 MasterSP），由主节点中的中央工作流引擎决定是否触发功能任务运行</p></blockquote><ul><li>带来的问题<ul><li>中央工作流引擎负责动态管理和调度所有功能。函数执行状态频繁地从主节点转移到工作节点，带来大量的调度开销。由于函数很短，这种传输会频繁发生。</li><li>引擎“随机”将触发的函数分发到工作节点以实现负载均衡，云厂商对函数的输入输出数据大小进行配额，以避免严重消耗网络带宽。在生产无服务器平台中，用户通常依赖额外的数据库存储服务来进行临时数据存储和交付，从而承受巨大的数据移动开销</li></ul></li></ul><h3 id="工作难点-1"><a href="#工作难点-1" class="headerlink" title="工作难点"></a>工作难点</h3><ul><li><p>WorkerSP: 大规模工作流划分为控制平面以及数据平面</p><ul><li>worker 函数可以执行自动缩放并重用热容器，这导致控制平面中的每个功能节点在数据中可能具有多个不同的数据平面</li><li>在无服务器工作流的实际控制平面（用户预定义）和数据平面（数据依赖）不一定相同的情况下，将大规模工作流划分为两个不同平面的多个工作人员时具有挑战性</li><li>考虑到集群中资源动态变化的前提，还需要一种基于实时资源可用性来划分和调度工作流的机制</li></ul></li><li><p>FaaStore: 利用主内存在函数之间交换数据</p><ul><li>没有理论指导</li></ul></li></ul><h3 id="相关工作-2"><a href="#相关工作-2" class="headerlink" title="相关工作"></a>相关工作</h3><ul><li>函数冷启动问题</li><li>Serverless Workflow 优化</li></ul><h3 id="模型定义-1"><a href="#模型定义-1" class="headerlink" title="模型定义"></a>模型定义</h3><ul><li>FaaSFlow<ul><li>工作流图调度程序在 <code>Master</code> 节点上运行。图调度器解析用户上传的工作流，根据每个工作节点上的可用资源和相邻功能之间传输的数据量将工作流划分为子图。</li><li>在每个 <code>Worker</code> 节点上，<ul><li>FaaSFlow 运行一个 <code>pre-worker</code> 工作流引擎来管理函数状态并触发本地函数任务，</li><li>一个集成的 FaaStore 在运行时动态分配容器中超额配置的内存</li></ul></li><li>FaaStore<ul><li>使用适当的数据存储（容器中分配良好的主内存或远程存储）来支持基于功能的位置和依赖性的通信。</li></ul></li></ul></li></ul><h4 id="Graph-Scheduler"><a href="#Graph-Scheduler" class="headerlink" title="Graph Scheduler"></a>Graph Scheduler</h4><h4 id="Per-Worker-Workflow-Engine"><a href="#Per-Worker-Workflow-Engine" class="headerlink" title="Per-Worker Workflow Engine"></a>Per-Worker Workflow Engine</h4><h4 id="Memory-Reclamation-in-FaaStore"><a href="#Memory-Reclamation-in-FaaStore" class="headerlink" title="Memory Reclamation in FaaStore"></a>Memory Reclamation in FaaStore</h4><h3 id="开源代码"><a href="#开源代码" class="headerlink" title="开源代码"></a>开源代码</h3><p><a href="https://github.com/lzjzx1122/FaaSFlow">https://github.com/lzjzx1122/FaaSFlow</a></p><h2 id="Distributed-Transactions-on-Serverless-Stateful-Functions"><a href="#Distributed-Transactions-on-Serverless-Stateful-Functions" class="headerlink" title="Distributed Transactions on Serverless Stateful Functions"></a><a href="https://dl.acm.org/doi/abs/10.1145/3465480.3466920">Distributed Transactions on Serverless Stateful Functions</a></h2><h3 id="解决问题-3"><a href="#解决问题-3" class="headerlink" title="解决问题"></a>解决问题</h3><p>当前的 Serverless 计算缺乏正确的状态管理支持，也缺乏函数到函数之间的调用能力</p><ul><li>在一个有状态的数据流引擎实现事务处理</li><li>提出一个在有状态的 Serverless 函数之间进行事务处理的编程模型</li><li>实现了两个在云应用使用的主要方法来实现事务处理保证：两阶段提交协议以及 Saga Workflow</li><li>在云基础设施上使用 YCSB 基准的扩展版本来评估两种事务方案</li></ul><h3 id="相关工作-3"><a href="#相关工作-3" class="headerlink" title="相关工作"></a>相关工作</h3><ul><li><p>Beldi 在有状态函数之间提供了拥有错误容忍的 ACID 事务处理</p><ul><li>方法：将函数的操作记录到 Serverless 云数据库</li></ul></li><li><p>Cloudburst 为形成 DAG 的功能工作流提供了因果一致性</p><ul><li>方法：通过 Anna，一个具有冲突解决策略的键值存储</li></ul></li></ul><h2 id="Durable-functions-semantics-for-stateful-serverless"><a href="#Durable-functions-semantics-for-stateful-serverless" class="headerlink" title="Durable functions: semantics for stateful serverless"></a><a href="https://dl.acm.org/doi/abs/10.1145/3485510">Durable functions: semantics for stateful serverless</a></h2><h3 id="解决问题-4"><a href="#解决问题-4" class="headerlink" title="解决问题"></a>解决问题</h3><p>FaaS 编程模式的无状态问题</p><h3 id="工作难点-2"><a href="#工作难点-2" class="headerlink" title="工作难点"></a>工作难点</h3><ul><li>持久化执行进度。许多应用需要大型或者长时间运行的函数的可靠执行，因此执行进度必须可持久化。由于大部分的语言运行时都不支持在一个正在运行的程序中检查状态，因此很难有一个简单自动且稳健的方式去持久化函数的执行进度</li><li>持久化应用状态。所有的可持久化的状态都必须通过外部的数据库进行存储，并且在使用时还必须显式地读写。由于 FaaS 的执行能力弱加上存储 API 的复杂性，这个过程也是困难的</li><li>恰好一次执行。旨在可靠的处理事件的触发存储器实际上并不能保证一次性执行。例如，当一个触发器触发一个函数处理消息队列中所有的消息的时候，就会带来消息的重复消费</li><li>同步性。并发控制必须通过外部服务来实现。租约迫使开发商根据时间假设进行工作，而电子标签只能检测冲突，而不能阻止冲突</li></ul><h3 id="相关工作-4"><a href="#相关工作-4" class="headerlink" title="相关工作"></a>相关工作</h3><ul><li>两种常见的有状态的 Serverless 抽象是 workflow 以及 actor<ul><li>Workflow<ul><li>Amazon Step functions</li><li>Azure Durable Functions</li><li>IBM Composer</li></ul></li><li>Actor<ul><li>Orleans</li><li>Durable Objects</li><li>Akka Serverless</li><li>Azure Durable Entities</li></ul></li></ul></li></ul><h3 id="Durable-Functions"><a href="#Durable-Functions" class="headerlink" title="Durable Functions"></a>Durable Functions</h3><p>  DF定义了三种基本的函数</p><ul><li>活动函数是DF中的无状态函数</li><li>实体是封装应用程序状态和流程操作的一个actor</li><li>编排函数使用任务并行的风格去协调活动函数和实体</li></ul><h4 id="Orchestrations"><a href="#Orchestrations" class="headerlink" title="Orchestrations"></a>Orchestrations</h4><p>编排允许开发人员通过将计算分解为任务来创建长时间运行的计算和工作流程。</p><ul><li>顺序组合</li><li>并行组合</li><li>持久化组合</li><li>客户端操作。客户端对象用来提供DF运行时的接口</li></ul><h4 id="Entities"><a href="#Entities" class="headerlink" title="Entities"></a>Entities</h4><p>实体允许应用程序封装持久状态，并定义可以对其执行的操作</p><ul><li>编排调用以及信号触发。编排函数可以通过调用或者发送信号的方式access实体</li><li>实体间信号。这可以实现有用的模式，例如使用实体来表示有状态的流操作符，甚至是复杂的数据流图</li><li>有序信号。DF 支持按指定传送时间安排信号。这对于需要在特定时间执行的操作非常有用</li></ul><h2 id="The-Serverless-Trilemma-Function-Composition-for-Serverless-Computing"><a href="#The-Serverless-Trilemma-Function-Composition-for-Serverless-Computing" class="headerlink" title="The Serverless Trilemma Function Composition for Serverless Computing"></a><a href="https://dl.acm.org/doi/pdf/10.1145/3133850.3133855">The Serverless Trilemma Function Composition for Serverless Computing</a></h2><h3 id="解决问题-5"><a href="#解决问题-5" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>描述了 Serverless 计算中关于函数组合的困难：Serverless trilemma<ul><li>函数需要在黑盒中进行</li><li>维护函数调用的可替代性原则</li><li>避免重复付费</li></ul></li></ul><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>在论文《The Serverless Trilemma: Function Composition for Serverless Computing》中的“Serverless Computing 简介”章节，提到了几个关键的概念和实践，以下是对这些概念的介绍：</p><ol><li><strong>Serverless Computing（无服务器计算）</strong>: 这一部分通过一个实例来介绍无服务器计算的价值提案。它描述了如何通过事件驱动的数据管道将两个现有服务连接起来。具体例子中，应用程序监控 Travis（持续集成工具）的构建失败，并通过 Slack（消息服务平台）发送通知。</li><li><strong>Functions as a Service（<strong><strong>函数即服务</strong></strong>，FaaS）</strong>: 描述了如何使用函数来响应特定事件。例如，在 Travis 构建完成时触发事件，这时需要一个用于数据格式转换的函数（Format），以及一个用于向 Slack 发送通知的函数（Post）。这些函数作为独立的单元被部署和调用，而不需要预先配置基础设施。</li><li><strong>Event-Driven Invocation（事件驱动调用）</strong>: 描述了如何基于特定事件（如 Travis 构建完成）触发函数调用。这类调用通常通过发布-订阅系统来实现，其中 OpenWhisk 使用触发器（trigger）来代表一个命名的话题。</li><li><strong>Componentization and Composition（组件化和组合)</strong>: 论文强调了将功能分解为更小、更专注的函数的重要性，这不仅促进了代码重用，也简化了整体架构。这部分讨论了如何在无服务器运行时环境中实现函数的组合，以及如何将一个函数的输出作为另一个函数的输入。</li></ol><h3 id="反应式模型"><a href="#反应式模型" class="headerlink" title="反应式模型"></a>反应式模型</h3><p>该章节描述了 OpenWhisk 的编程模型，刻画了反应式模型在 OpenWhisk 中的应用</p><ol><li><strong>OpenWhisk 编程模型</strong>: 这一节为论文的其他部分奠定了基础，通过介绍 OpenWhisk 的核心编程模型。OpenWhisk 是一个开源的无服务器平台，其核心特性包括反应式调度器和反射能力。</li><li><strong>反应式调度器(<strong><strong>reactive</strong></strong> scheduler)</strong>: OpenWhisk 的核心包括一个反应式调度器，用于调度单一的、完整的动作（actions）。这种调度方式是基于事件驱动的，意味着动作的执行是由外部事件触发的。</li><li><strong>反射能力(reflective capability)</strong>: 通过反射调用（reflective invocation），一个动作可以控制其他动作的调度。这意味着在 OpenWhisk 中，一个函数可以触发或控制另一个函数的执行。</li><li><strong>外部调度器的能力与限制</strong>: 第四节将展示这种类型的外部调度器的能力与限制，其中“外部调度器”指的是不属于 OpenWhisk 核心部分的实体，它管理动作的调用。在这种情况下，程序完全利用核心调度器进行操作，这些程序被称为静态或静态调度程序。</li><li><strong>模型的抽象语法</strong>: 论文中还描述了该模型的抽象语法的语法表，从这个模型中可以直接映射到 OpenWhisk 的实际编程实践。</li></ol><p><img src="/../assets/serverless_workflow/FUeqbOFuHoswTYx6dgbclH28nMc.png"></p><ol><li><strong>触发器(triggers)<strong>：模型使用触发器来表示事件。一个程序包含了一个或者多个规则，一个规则描述了一个触发器</strong>何时</strong>执行并且<strong>执行什么</strong>；</li></ol><h4 id="OpenWhisk-Actions"><a href="#OpenWhisk-Actions" class="headerlink" title="OpenWhisk Actions"></a>OpenWhisk Actions</h4><ol><li><strong>Stateless Function</strong>: OpenWhisk 中的动作（Action）被定义为一个无状态的函数，每个动作都有一个唯一的名称。</li><li><strong>输入与输出</strong>: 动作的输入是一个字典（Dictionary），即一组键值对。动作的输出是另一个字典（如果动作成功完成），或者是一个失败的指示。这里采用了 Scala 的 Try 类型，表示动作调用的结果可能是成功的类型 T 或者是系统的错误类型。一个 Action 可以通过下列公式进行表示</li></ol><p>$$<br>a.invoke: Dictionary \rightarrow Try[Dictionary]<br>$$</p><ol><li><p><strong>日志输出</strong>: 除了正常的响应外，动作也可能产生日志输出的副通道。一个动作的日志被认为是一个可能为空的日志记录列表。为了性能考虑，日志记录仅在事后可访问。</p></li><li><p><strong>无状态性（Statelessness）</strong>: 一个 action 不能假设从一个调用到下一个调用会<strong>持续存在词法状态</strong>。这种无状态性简化了调度和扩展的解决方案</p><ol><li>如果需要将状态传递给未来的调用，action 负责安排适当的外部机制。例如，状态可以外部化到托管的文档存储，如 Amazon 的 S3 或 IBM 的 Cloudant。</li></ol></li><li><p><strong>最多一次调用语义（At-Most-Once Invocation Semantics）</strong>: 在分布式系统中，无法保证完全准确一次的传递。因此，实现只需保证最多一次的语义，即每次动作的调用。</p></li></ol><h4 id="柯里化函数应用"><a href="#柯里化函数应用" class="headerlink" title="柯里化函数应用"></a>柯里化函数应用</h4><p>在论文《The Serverless Trilemma: Function Composition for Serverless Computing》中提到的“Curried Function Application”（柯里化函数应用）是指在无服务器计算环境中，将特定的值（键值对）绑定到一个函数上，从而创建一个新的函数版本的过程。</p><p>具体来说，当你有一个动作（函数）<code>a</code> 和一组键值对 <code>M</code> 时，你可以通过将 <code>a</code> 根据 <code>M</code> 中的变量赋值进行柯里化，来创建一个新的动作 <code>a&#39;</code>。这个过程被称为 <code>a.with(M)</code>。结果产生的动作 <code>a&#39;</code> 被视为 <code>a</code> 的一个绑定版本。</p><p>操作上，如果你调用 <code>a.with(M).invoke(D)</code>，你实际上是在调用一个与映射 <code>M</code> 柯里化并且用实际参数 <code>D</code> 调用的动作。</p><p>柯里化函数应用在无服务器架构中特别有用，因为它允许动态地创建具有特定配置的函数版本，而无需为每种可能的配置编写单独的代码。这种方法提高了代码的复用性，并简化了在无服务器环境中函数组合的处理。</p><h4 id="包：命名空间与批量柯里化"><a href="#包：命名空间与批量柯里化" class="headerlink" title="包：命名空间与批量柯里化"></a>包：命名空间与批量柯里化</h4><ol><li>命名空间和动作分组: OpenWhisk 允许将动作（Actions）在特定的命名空间下进行分组。这种分组以包（Package）的形式出现，一个包 <code>P</code> 是一组动作 <code>Ap</code> 的集合。</li><li>批量柯里化: 包中的动作可以通过 <code>with</code> 绑定组合。例如，对于包 <code>P</code> 和其中的动作 <code>a</code>，调用 <code>P.with(Mp).a.with(Ma).invoke(P)</code> 表示首先应用包级别的变量赋值 <code>Mp</code>，然后是动作级别的 <code>Ma</code>，最后是实际参数。这样的处理方式使得变量赋值 <code>Mp</code> 在实际参数和动作级别柯里化之后，作为第三优先级来源。</li><li>抽象和隔离: 包的柯里化提供了一个有用的抽象，特别是在处理凭证和其他秘密信息时。绑定允许程序隔离凭证，以便它们只暴露给需要它们的动作。</li></ol><h4 id="OpenWhisk-Triggers"><a href="#OpenWhisk-Triggers" class="headerlink" title="OpenWhisk Triggers"></a>OpenWhisk Triggers</h4><ol><li>消息队列的表示: OpenWhisk 的编程模型将消息队列表现为两种操作，这些操作是基于命名主题的，称为触发器（triggers）。</li><li>触发器类型构造: 使用类型构造函数 <code>Trigger[t]</code>，可以构建一个新的触发器子类型，其中 <code>t</code> 是应用程序中识别主题的字符串。</li><li>触发器代表消息类: 触发器 <code>Trigger[t]</code> 代表一类消息，可以简单地表示为 <code>t</code>。消息被认为是字典类型（Dictionary），与动作的输入和输出格式相同。</li><li>创建和通知消息: 对于给定主题 <code>t</code> 和有效载荷 <code>D</code>，<code>t.fire(D)</code> 操作用于构造一个带有此有效载荷的新消息，并通知消息队列其到达。例如，要在 “build_done” 主题上创建表示成功构建的消息，可以使用 <code>Trigger[&quot;build_done&quot;].fire(status → &quot;success&quot;)</code>。</li></ol><h4 id="通过触发器进行反应式调用"><a href="#通过触发器进行反应式调用" class="headerlink" title="通过触发器进行反应式调用"></a>通过触发器进行反应式调用</h4><p>我们已经介绍了触发器(trigger)以及动作(action)，他们直接通过一个 <code>when</code> 的语法进行连接。</p><p><img src="/../assets/serverless_workflow/DTyibRzCconL1Lxg0CjchBLfnJh.png"></p><ul><li>规则(Rule): 描述了从触发器到动作之间的联系。<code>t.when(a)</code><ul><li>包含多个状态位：决定了 t 是否发送消息</li><li>允许程序分离他们对于 actions 触发的管理</li></ul></li></ul><h4 id="部署与反思"><a href="#部署与反思" class="headerlink" title="部署与反思"></a>部署与反思</h4><ol><li>动作部署（Deployment）: 当一个动作的源代码准备好后，它可以被部署。只有在部署之后，这个动作才可以被调用。每个已部署的动作都有一个独特的远程调用端点。</li><li>触发器部署: 类似地，一旦触发器（Trigger）被部署，它也会收到一个独特的远程触发端点。</li><li>反射式调用（Reflective Invocation）: 使用这些远程端点，一个动作在其调用期间可以调用另一个动作。这种动作调用动作的过程被称为反射式调用。</li><li>内省功能（Introspective Facilities）: 这些内省功能允许在核心提供的组合器之外，使用一般用途语言的全部功能进行新类型组合器的实验。通过对静态组合的属性进行内省，可以将新的组合器作为无服务器动作编程。</li><li>内省 API: 论文假设内省 API 以 JavaScript 库的形式呈现，可供实现为 JavaScript 的无服务器动作使用。为了清晰的展示，将使用由核心模型提供的内省函数的符号表示，这些包括动作、触发器和规则函数，它们分别代表各自实体的构造器。这些反射式构造器允许进行元编程，这是论文后续将更详细探讨的一个场景。</li></ol><h3 id="The-Serverless-Trilemma"><a href="#The-Serverless-Trilemma" class="headerlink" title="The Serverless Trilemma"></a>The Serverless Trilemma</h3><ol><li>序列组合的引入: 在核心模型中，序列组合允许程序从两个给定的动作中构造一个新的动作。这种新动作的调用含义将通过 flatMap 单子组合的语义来精确定义：序列表现为数据管道，其中唯一的隐式通信发生在动作间的连接点，且在第一个失败的动作处执行短路。</li><li>序列组合器“then”: 作者引入了一个所期望的序列组合器，称为“then”。例如，组合 <code>a.then(b).then(c)</code> 应该等同于一个新的动作 <code>s</code>，使得输入到 <code>s</code> 的内容成为输入到 <code>a</code> 的内容，而 <code>s</code> 的输出与表达式 <code>c(b(a()))</code> 的输出相同。</li></ol><h4 id="双重计费约束"><a href="#双重计费约束" class="headerlink" title="双重计费约束"></a>双重计费约束</h4><p>文章首先定义了什么是双重计费，即一个函数调用另一个函数的时候，该调用函数必须等待被调用函数执行完毕才停止，带来了执行时间上的浪费问题</p><p><img src="/../assets/serverless_workflow/TuPQbU3Xdox42IxIDI6ca8WPnHd.png"></p><h4 id="黑盒约束"><a href="#黑盒约束" class="headerlink" title="黑盒约束"></a>黑盒约束</h4><ul><li>函数流上的多个函数需要能够支持不同语言的函数执行</li><li>函数需要通过 Action 进行触发</li></ul><h4 id="可替代原则"><a href="#可替代原则" class="headerlink" title="可替代原则"></a>可替代原则</h4><p>希望动作的组合本身就是动作。以下是可能得解决方案</p><ol><li><p>反射调用</p><ol><li>使用调度程序调用多个函数，但是调度程序在其组成部分的活动时间内要保持活跃状态，带来双重计费</li></ol></li><li><p>连续传递</p><ol><li>通过让操作调用延续（即序列的其余部分）来调度序列。</li><li>该方法使用 <code>triggers</code> 和 <code>rules</code> 来实现</li><li>通过关联每个完成触发器与每个动作，当一个动作的调用完成时，调用会触发被关联的完全触发器。例如一个序列$a.then(b)$,a 的一个完全触发器被表示为$ct(a)$,那么就创建一个规则$ct(a).when(b)$。当 a 的完全触发器被调用时，就计划一个对于 b 的调用</li><li>当通过触发调用实现函数组合时，这种连续性可能会被破坏，因为触发的调用<strong>往往涉及到<strong><strong>异步处理</strong></strong>和事件驱动的机制</strong>。这可能意味着当一个函数调用另一个函数时，后者可能不会立即执行，而是在满足某些条件或接收到特定事件时才触发。这种行为的差异可能导致无法保持原始的同步调用模式，从而违反了可替代原则。<br>在这样的场景中，组合的函数无法简单地被视为相互替代的，因为它们的执行依赖于外部事件或触发器，而不仅仅是输入参数。这种异步性和依赖于事件的特性使得函数的组合变得更加复杂，并引入了额外的考虑因素，如状态管理、事件处理和调用顺序的控制。</li></ol></li><li><p>客户端调度程序</p><ol><li>当前仅当客户端程序实现了所有在 OpenWhisk 中可能的组合，该方法才算实现了可替代原则</li></ol></li></ol><h3 id="OpenWhisk-Invocation-Flow"><a href="#OpenWhisk-Invocation-Flow" class="headerlink" title="OpenWhisk Invocation Flow"></a>OpenWhisk Invocation Flow</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>包含了 4 个组件</p><p><img src="/../assets/serverless_workflow/DSBCbxR8ooLUF6xPamYcNmOWnfe.png"></p><p>当一个调用请求到来时</p><ol><li><code>controller</code> 首先选择 hosts 池子中的一个 <code>invoker</code></li><li>将请求信息放到一个 <code>message queue</code> 中</li><li>每个 <code>invoker</code> 都托管了多个容器，将多个调用分离开</li><li><code>invoker</code> 订阅了指向他们的事件，当资源可用时，将调用请求注入到容器中，此时，调用开始</li><li>当一个调用结束时，<code>invoker</code> 将结果存储到 <code>system of record</code> 中，向控制器指示它现在可以响应客户端</li></ol><h4 id="Active-ack"><a href="#Active-ack" class="headerlink" title="Active ack"></a>Active ack</h4><ul><li>管道旁路的微架构策略</li></ul><p><img src="/../assets/serverless_workflow/OpgobpKlxoUeVbxd5HccFkHsnWf.png"></p><p>调用者以绕过系统记录的方式发出完成信号。<code>ack action</code> 使用消息队列作为计分板，将调用者的结果转发到控制器，以便控制器可以在调用完成时快速采取行动。</p><h4 id="Active-ACK-应用"><a href="#Active-ACK-应用" class="headerlink" title="Active ACK 应用"></a>Active ACK 应用</h4><p>通过应用 Active ACK 后，将发生如下的变化</p><ol><li>创建一个 <code>action</code> 的时候，必须指定该 <code>action</code> 为序列，然后指定构成组合的组件 OpenWhisk actions</li><li>控制器必须特殊处理序列 <code>action</code> 的调用</li></ol><p><img src="/../assets/serverless_workflow/BEvob9xv5oLYXNxz5U9cPSoAnWg.png"></p><p>在处理序列的调用时，在收到主动确认后，控制器会排列序列中下一个操作的调用。重复此排队调用和主动确认消息的循环，直到控制器到达操作列表的末尾。此时，它用最终的主动确认负载响应客户端。</p><h3 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h3><p>对序列之外的组合模式的需求，有三类这样的组合器：ECA 模型、重试以及数据转发。</p><p><img src="/../assets/serverless_workflow/FQXgbU5o5oTsAfxCFLCcLwmOn1c.png"></p><h4 id="ECA"><a href="#ECA" class="headerlink" title="ECA"></a>ECA</h4><p>来自 Travis 的通知消息包含无关的详细信息。因此，应用程序在步骤 1 中投影出相关字段：构建标识符和构建状态。如果构建失败（步骤 2），应用程序将继续执行步骤 3。</p><p>为了实现 ECA 这样的模型，下列代码展示了一个组合器，通过 condition 以及 action。当提供了入参 args 时，它将触发条件。</p><p><img src="/../assets/serverless_workflow/JG2jbcdMJoljKxxC7qEcr3pqnAb.png"></p><h4 id="元程序重试"><a href="#元程序重试" class="headerlink" title="元程序重试"></a>元程序重试</h4><p>为了重试，我们可以编写一个元程序，将函数作为输入，并调用它直到成功。清单 5 说明了这个重试元程序。我们想要的 VerifyAndAnalyze 函数现在可以表示为 Retry 的绑定，其中操作参数 A 绑定到 VerifyThenAnalyze。</p><p><img src="/../assets/serverless_workflow/Q3sObQMVAowi7Mx8WzDc2Ls2nmc.png"></p><h4 id="元程序数据转发"><a href="#元程序数据转发" class="headerlink" title="元程序数据转发"></a>元程序数据转发</h4><p>图中步骤 3 的输出(a,b)其中之一将进入到步骤 4 跟 5，另一个需要在 4 跟 5 执行后跟着 c 一起呗转发到 6，由于从 Retry action 返回的值还未实现，因此只能通过下列代码进行</p><p><img src="/../assets/serverless_workflow/Kq8rbg0g3o8iUexQ8rjcZ6UnnjS.png"></p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Serverless</tag>
      
      <tag>Function orchestration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统复习提纲</title>
    <link href="/2024/01/01/dis_sys/"/>
    <url>/2024/01/01/dis_sys/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="分布式系统的定义"><a href="#分布式系统的定义" class="headerlink" title="分布式系统的定义"></a>分布式系统的定义</h2><ul><li>分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像是单个相关系统</li><li>为了使各类异构的计算机和网络都呈现为单个的系统，分布式系统常常通过一个软件层组织起来，这样的分布式系统有时又称为中间件</li></ul><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li><p>使资源可访问</p></li><li><p>透明性：如果一个分布式系统能够在用户和应用程序面前呈现为单个计算机系统，这样的分布式系统就称为是透明的</p><ul><li>访问透明性：对不同数据的表示形式以及资源访问的隐藏</li><li>位置透明性：用户无法感知到资源在系统中的物理位置</li><li>迁移透明性：分布式系统的资源迁移不会影响该资源的访问方式</li><li>重定向透明性：资源可以在接收访问的同时进行重新定位而不引起用户和应用程序的注意</li><li>复制透明性：对同一资源存在多个副本这样一个事实的隐藏</li><li>并发透明性：确保对共享资源的并发访问不会破坏资源的一致状态</li><li>故障透明性：用户不会注意到某个资源无法正常工作</li></ul></li><li><p>开放性</p><ul><li>开放的分布式系统：根据一系列准则来提供服务，这些准则描述了服务的语法与语义</li><li>分布式系统中服务通常通过接口指定，接口一般是通过接口定义语言描述</li><li>互操作性：来自不同厂商的系统或组件的两种实现能够在何种程度上共存并且协同工作</li><li>可移植性</li><li>做法：策略与机制分离<ul><li>机制：对应一个接口。例如万维网的缓存机制</li><li>策略：对应具体做法。允许用户修改缓存策略</li></ul></li></ul></li><li><p>可扩展性</p><ul><li>规模上扩展</li><li>地域上扩展</li><li>管理上扩展</li></ul></li></ul><h2 id="分布式系统的类型"><a href="#分布式系统的类型" class="headerlink" title="分布式系统的类型"></a>分布式系统的类型</h2><h3 id="分布式计算系统"><a href="#分布式计算系统" class="headerlink" title="分布式计算系统"></a>分布式计算系统</h3><h4 id="集群计算系统"><a href="#集群计算系统" class="headerlink" title="集群计算系统"></a>集群计算系统</h4><ul><li>每个群都是由一个计算机节点集组成的，它们可以由单个主节点来控制和访问</li></ul><h4 id="网格计算系统"><a href="#网格计算系统" class="headerlink" title="网格计算系统"></a>网格计算系统</h4><ul><li>网格计算系统具有高度的异构性：其硬件、操作系统、网络、管理域和安全策略等都不尽相同</li></ul><h3 id="分布式信息系统"><a href="#分布式信息系统" class="headerlink" title="分布式信息系统"></a>分布式信息系统</h3><h4 id="事务处理系统"><a href="#事务处理系统" class="headerlink" title="事务处理系统"></a>事务处理系统</h4><p>对事务处理的程序要求有特定的原函数，即必须能被底层的分布式系统或编程语言的运行时系统所支持。</p><ul><li>事务的 4 个特性<ul><li>原子性：对于外部来说，事务处理是不可见的</li><li>一致性：事务处理不会违反系统的不变性</li><li>独立性：并发的事务处理不会互相干扰</li><li>持久性：事务处理一旦提交，所发生的改变是永久性的</li></ul></li></ul><h4 id="企业应用集成"><a href="#企业应用集成" class="headerlink" title="企业应用集成"></a>企业应用集成</h4><ul><li>通信中间件<ul><li>远程过程调用：通过一个本地过程调用，有效地往另一个应用程序组件发送一个请求</li><li>远程方法调用：操作的是对象而不是应用程序</li><li>面向消息的中间件：发布订阅系统</li></ul></li></ul><h3 id="分布式普适系统"><a href="#分布式普适系统" class="headerlink" title="分布式普适系统"></a>分布式普适系统</h3><h1 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h1><h2 id="体系结构的样式"><a href="#体系结构的样式" class="headerlink" title="体系结构的样式"></a>体系结构的样式</h2><ul><li>分层体系结构：计算机网络</li><li>基于对象的体系结构：RPC</li><li>以数据为中心的体系结构：Web</li><li>基于事件的体系结构：发布订阅系统</li></ul><h2 id="系统体系结构"><a href="#系统体系结构" class="headerlink" title="系统体系结构"></a>系统体系结构</h2><h3 id="集中式体系结构"><a href="#集中式体系结构" class="headerlink" title="集中式体系结构"></a>集中式体系结构</h3><ul><li>应用分层</li><li>多层体系结构</li></ul><h3 id="非集中式体系结构"><a href="#非集中式体系结构" class="headerlink" title="非集中式体系结构"></a>非集中式体系结构</h3><ul><li>结构化点对点体系结构</li><li>非结构化的点对点体系结构</li><li>覆盖网络的拓扑管理</li><li>超级对等体</li></ul><h3 id="混合体系结构"><a href="#混合体系结构" class="headerlink" title="混合体系结构"></a>混合体系结构</h3><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="代码迁移"><a href="#代码迁移" class="headerlink" title="代码迁移"></a>代码迁移</h2><h3 id="代码迁移方案"><a href="#代码迁移方案" class="headerlink" title="代码迁移方案"></a>代码迁移方案</h3><ul><li><p>理由：把进程由负载较重的机器上转移到负载较轻的机器上去</p></li><li><p>代码迁移模型</p><ul><li>代码段</li><li>资源段</li><li>执行段</li></ul></li><li><p>形式</p><ul><li>弱可移动性：代码段与初始化数据</li><li>强可移动性：传输执行段</li></ul></li></ul><p><img src="/../assets/dissys/PbFmbBg6logxpXx6uk2cZPeQn5g.png"></p><h3 id="迁移与本地资源"><a href="#迁移与本地资源" class="headerlink" title="迁移与本地资源"></a>迁移与本地资源</h3><ul><li>按标识符绑定：进程明确指定的只是要引用哪些资源</li><li>按类型绑定：进程指指明它需要哪一种类型的资源</li></ul><h3 id="异构系统中的代码迁移"><a href="#异构系统中的代码迁移" class="headerlink" title="异构系统中的代码迁移"></a>异构系统中的代码迁移</h3><h1 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="通信类型"><a href="#通信类型" class="headerlink" title="通信类型"></a>通信类型</h3><ul><li>持久通信：提交传输的消息一直由通信中间件存储，直到该消息被传送给接收方为止</li><li>瞬时通信：通信系统只有在发送和接收应用程序正在运行时才存储消息</li><li>异步通信：发送方在提交要传输的消息立即往下执行</li><li>同步通信：发送方将被阻塞，直到知道其请求被接受以后</li></ul><h2 id="远程过程调用"><a href="#远程过程调用" class="headerlink" title="远程过程调用"></a>远程过程调用</h2><p>机器 A 上的进程调用机器 B 上的进程时，A 上的调用进程被挂起，而 B 上的被调用进程开始执行</p><p>总的来说，远程过程调用包含下列步骤：</p><ol><li>客户过程以正常的方式调用客户存根</li><li>客户存根生成一个消息，然后调用本地操作系统</li><li>客户端操作系统将消息发送给远程操作系统</li><li>远程操作系统将消息发给服务器存根</li><li>服务器存根将参数提取出来，然后调用服务器</li><li>服务器执行要求的操作，操作完成后将结果返回给服务器存根</li><li>服务器存根将结果打包成一个消息，然后调用本地操作系统</li><li>服务器操作系统将含有结果的消息发送回客户端操作系统</li><li>客户端操作系统将消息交给客户存根</li><li>客户存根将结果从消息中提取出来，返回给调用它的客户过程</li></ol><h1 id="命名系统"><a href="#命名系统" class="headerlink" title="命名系统"></a>命名系统</h1><h2 id="名称、标识符和地址"><a href="#名称、标识符和地址" class="headerlink" title="名称、标识符和地址"></a>名称、标识符和地址</h2><ul><li><p>访问点：要对实体进行操作，就需要访问实体，因此需要一个访问点</p></li><li><p>地址：访问点的名称称为地址</p></li><li><p>标识符：具有以下属性的名称</p><ul><li>一个标识符最多引用一个实体</li><li>每个实体最多由一个标识符引用</li><li>一个标识符始终引用同一个实体</li></ul></li></ul><h2 id="无层次命名"><a href="#无层次命名" class="headerlink" title="无层次命名"></a>无层次命名</h2><h3 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h3><ul><li><p>广播与多播：随着网络的膨胀广播开始变得低效</p></li><li><p>转发指针：</p><ul><li>链可能会特别长</li><li>只要需要，链中的所有中间位置就必须维护它们的那一部分转发指针链</li><li>所在的链很脆弱，易断开</li></ul></li></ul><h3 id="基于宿主位置的方法"><a href="#基于宿主位置的方法" class="headerlink" title="基于宿主位置的方法"></a>基于宿主位置的方法</h3><ul><li><p>每个移动主机都有一个固定的 IP 地址，所有与该 IP 地址进行的通信一开始都被转发到移动主机的宿主代理中</p></li><li><p>当一台移动主机转移到另一个网络中时，它会请求一个可以用来通信的临时地址，这种转交地址要在宿主代理中注册</p></li><li><p>当宿主代理接收到发给移动主机的数据包时，它会查找主机的当前位置</p><ul><li>如果主机是在当前本地网络中，那么就只需转发数据包</li><li>否则，建立一条通往主机当前位置的通道，也就是说，它会把数据组装成 IP 包，然后发送给转交地址。同时，将把主机的当前位置告诉数据包的发送者</li></ul></li><li><p>缺点：</p><ul><li>必须保证宿主位置始终存在</li></ul></li></ul><h3 id="分层方法"><a href="#分层方法" class="headerlink" title="分层方法"></a>分层方法</h3><ul><li>分层方案中，网络被划分为一组域，有一个覆盖整个网络的顶级域，每个域又可以进一步分成多个更小的子域</li><li>查询操作</li></ul><p><img src="/../assets/dissys/OaQgbMXlFoTgVgx6s72cYO3vnmb.png"></p><ul><li>更新操作</li></ul><p><img src="/../assets/dissys/TNRob81TyoXRw7xLZMGc8yO0nBd.png"></p><h1 id="同步化"><a href="#同步化" class="headerlink" title="同步化"></a>同步化</h1><h2 id="时钟同步"><a href="#时钟同步" class="headerlink" title="时钟同步"></a>时钟同步</h2><h3 id="时钟同步算法"><a href="#时钟同步算法" class="headerlink" title="时钟同步算法"></a>时钟同步算法</h3><ul><li><p>网络时间协议：客户与时间服务器联系<br><img src="/../assets/dissys/XDwKbUnfEoxK9yxz57jc5TrTnKb.png"></p><ul><li>创建了两条连接，B 也可以探查 A 的当前时间，延时的计算如下</li></ul><p>$$<br>igma &#x3D; \frac{(T_2-T_1) + (T_4-T_3)}{2}<br>$$</p></li><li><p>Berkeley 算法</p><ul><li>时间服务器是主动的，定期地询问每台机器的时间</li><li>基于这些回答，计算出一个平均时间，并告诉所有其他机器将它们的时钟拨快到一个新的时间</li><li>基于这些回答，计算出一个平均时间</li></ul></li></ul><h2 id="逻辑时钟"><a href="#逻辑时钟" class="headerlink" title="逻辑时钟"></a>逻辑时钟</h2><h3 id="Lamport-逻辑时钟"><a href="#Lamport-逻辑时钟" class="headerlink" title="Lamport 逻辑时钟"></a>Lamport 逻辑时钟</h3><ul><li>计数器更新<ul><li>在执行一个事件之前（如在网络上发送一个消息，传送一个消息给应用程序，或者其他内部事件），$P_i$执行$C_i \leftarrow C_i+1$</li><li>当进程$P_i$发送一个消息 m 给$P_i$时，在执行前面的步骤后，把 m 的时间戳$ts(m)$设置为等于$C_i$</li><li>在接收消息 m 时，进程$P_i$调整自己的局部计数器为$C_j \leftarrow \max {C_i, ts(m)}$，然后执行第一步，并把消息传送给应用程序</li></ul></li></ul><h3 id="向量时钟"><a href="#向量时钟" class="headerlink" title="向量时钟"></a>向量时钟</h3><ul><li>Lamport 不能捕获因果关系</li></ul><p><img src="/../assets/dissys/LfSibII6goQqEqxuuGicjN01n1d.png"></p><ul><li><p>向量时钟的创建是通过让每个进程$P_i$维护一个向量$VC_i$来完成的，该向量具有下面两个性质</p><ul><li>$VC_i[i]$是到目前为止进程$P_i$发生的事件的数量</li><li>如果$VC_i[j]&#x3D;k$,那么进程$P_i$知道进程$P_j$中已经发生了 k 个事件。因此，$P_i$知道$P_j$的逻辑时间</li></ul></li><li><p>步骤</p><ul><li>在执行一个事件之前（如在网络上发送一个消息，传送一个消息给应用程序，或者其他内部事件），$P_i$执行$VC_i[i] \leftarrow VC_i[i] + 1$</li><li>当进程$P_i$发送一个消息 m 给$P_i$时，在执行前面的步骤后，把 m 的时间戳$ts(m)$设置为等于$VC_i$</li><li>当接收消息 m 时，进程$P_j$通过为每个 k 设置$VC_j[k] \leftarrow \max { VC_j[k], ts(m)[k] }$来调整自己的向量。然后，执行第一步，并把自己的消息传送给应用程序</li></ul></li></ul><h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><h3 id="集中式算法"><a href="#集中式算法" class="headerlink" title="集中式算法"></a>集中式算法</h3><p>选举一个进程作为协作者，无论何时一个进程要访问共享资源，都要向协作者发送一个请求消息，说明它想要访问哪个资源并请求准许</p><h3 id="分布式算法"><a href="#分布式算法" class="headerlink" title="分布式算法"></a>分布式算法</h3><p>该算法的工作过程如下：当一个进程要访间一个共享资源时，它构造一个消息，其中包含它要访问的资源名、它的进程号和当前（逻辑）时间。然后，它将该消息发送给所有其他的进程，理论上讲也包括它自己，假设消息的传送是可靠的，也就是说，没有消息丢失。</p><p>当一个进程接收到来自另一个进程的请求消息时，它根据自己与消息中的资源相关的状态来决定它要采取的动作。可以分为三种情况</p><ul><li>若接收者没有访问资源，而且也不想访问它，就向发送者发送一个 OK 消息。</li><li>若接收者已获得对资源的访问，那么它就不进行应答，而是将该请求放入队列中。</li><li>如果接收者想访问费源但尚未访问时，它收到的消息的时间截与包含在它发送给其他进程的消息中的时间藏进行比较。时间戳最早的那个进程获胜。如果收到的消息的时间截比较早，那么接收者向发送者发回一个 OK 消息，如果它自己的消息的时间截比较队列中，并且不发送任何消息</li></ul><p><img src="/../assets/dissys/WaBbb45MXonGXhx1ROcc5HhSnob.png"></p><h3 id="令牌环算法"><a href="#令牌环算法" class="headerlink" title="令牌环算法"></a>令牌环算法</h3><ul><li><p>环初始化时，进程 0 得到一个令牌</p></li><li><p>令牌绕着环运行，用点对点发送消息的方式把令牌从进程 k 传到进程 k+1</p></li><li><p>拿到令牌的资源检查自己是否需要访问资源</p><ul><li>要。继续完成要做的工作，然后释放资源</li><li>不要。向下传递</li></ul></li></ul><h2 id="选举算法"><a href="#选举算法" class="headerlink" title="选举算法"></a>选举算法</h2><h3 id="传统的选举算法"><a href="#传统的选举算法" class="headerlink" title="传统的选举算法"></a>传统的选举算法</h3><ul><li><p>欺负算法</p><ul><li>任何一个进程发现协作者不再响应请求的时候，它就发起一次选举，按照如下过程<ul><li>P 向所有编号比它大的进程发送一个 <code>ELECTION</code> 消息</li><li>如果无人响应，P 获胜并成为协作者</li><li>如果有编号比它大的进程的响应，则由响应者接管选举工作，P 的工作完成</li></ul></li></ul></li><li><p>环算法</p><ul><li>当任何一个进程注意到协作者不工作时，它就构造一个带有他自己的进程号的 <code>ELECTION</code> 消息并把消息发送给它的后继者</li><li>如果后继者崩溃了，发送者沿着此环跳过它的后继者发送给下一个进程，直到找到一个正在运行的进程</li><li>最终消息返回到此次选举的进程，当发起者进程接收到一个包含它自己的进程号的消息时，它识别出这个事件。此时该进程再一次绕环运行，向所有进程通知谁是协作者</li></ul></li></ul><h1 id="一致性与复制"><a href="#一致性与复制" class="headerlink" title="一致性与复制"></a>一致性与复制</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul><li><p>可靠性</p><ul><li>当一个副本被破坏后，文件系统只需转换到另一个数据副本就可以继续执行下去</li></ul></li><li><p>性能</p><ul><li>当分布式系统需要在服务器数量和地理区域上进行扩展时，复制对于提高性能时相当重要的</li></ul></li></ul><h2 id="以数据为中心的一致性模型"><a href="#以数据为中心的一致性模型" class="headerlink" title="以数据为中心的一致性模型"></a>以数据为中心的一致性模型</h2><h3 id="严格一致性"><a href="#严格一致性" class="headerlink" title="严格一致性"></a>严格一致性</h3><p>任何读的结果都是最近的一次写的结果</p><p><img src="/../assets/dissys/UYJqbDvyUoXXBZxnDydcKiwLn7g.png"></p><h3 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h3><p>任何执行结果都是相同的，就好像所有进程对数据存储的读写操作是按照某种序列顺序执行的，并且每个进程的操作按照程序所制定的顺序出现在这个序列中</p><p><img src="/../assets/dissys/Q4QGbhriBo58b6xgFERcVwOMnkf.png"></p><h3 id="线性一致性"><a href="#线性一致性" class="headerlink" title="线性一致性"></a>线性一致性</h3><p>所有进程的读写都以某种串行方式执行，顺序以及各个进程的操作维持的顺序是指定的</p><h3 id="因果一致性"><a href="#因果一致性" class="headerlink" title="因果一致性"></a>因果一致性</h3><p>一种弱化的顺序一致性模型，将具有潜在因果关系的事件和没有因果关系的事件区分开来</p><ul><li>所有进程必须以相同的顺序看到具有潜在因果关系的写操作，不同机器上可以以不同的顺序看到并发的写操作</li></ul><p><img src="/../assets/dissys/OJfIbPskSo5yuexGMaBcJAz1nYd.png"></p><h3 id="FIFO-一致性"><a href="#FIFO-一致性" class="headerlink" title="FIFO 一致性"></a>FIFO 一致性</h3><p>通过单一的进程写在其他的进程看来顺序是一致的，但是不同的进程写在其他的进程看来就未必一致</p><p><img src="/../assets/dissys/WwRsb4zvcoWtnuxdPqucYiCvnec.png"></p><h3 id="弱一致性"><a href="#弱一致性" class="headerlink" title="弱一致性"></a>弱一致性</h3><p>在所有先前的所有写入都已到处完成之前，不允许对同步变量进行任何操作</p><h3 id="释放一致性"><a href="#释放一致性" class="headerlink" title="释放一致性"></a>释放一致性</h3><p>在对共享变量的读写操作释放之前，之前所有的请求都必须被成功执行</p><p><img src="/../assets/dissys/N76ObRwxMokGQAxmdTXcsXrIn2f.png"></p><h3 id="入口一致性"><a href="#入口一致性" class="headerlink" title="入口一致性"></a>入口一致性</h3><p>不允许执行同步变量的获取访问，直到对受保护的共享数据的所有更新都已完成为止</p><p><img src="/../assets/dissys/HXtobaw3boKRzJxJ6BfcIwYgnUc.png"></p><h2 id="以客户为中心的一致性模型"><a href="#以客户为中心的一致性模型" class="headerlink" title="以客户为中心的一致性模型"></a>以客户为中心的一致性模型</h2><h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><ul><li><p>为什么要最终一致性？</p><ul><li>大多数进程几乎从不执行更新操作，而只从数据库读取数据</li><li>只有部分进程被允许更新名称空间中它所负责的部分，基本不会出现写-写操作冲突，唯一需要处理的情况是读-写操作冲突。这种情况通常允许以懒惰的方式传播更新操作</li></ul></li><li><p>什么是最终一致性？</p><ul><li>如果在一段很长的时间内没有更新操作，那么所有的副本将逐渐地成为一致的，这种形式的一致性称为最终一致性</li></ul></li></ul><h3 id="单调读一致性"><a href="#单调读一致性" class="headerlink" title="单调读一致性"></a>单调读一致性</h3><ul><li>定义<ul><li>如果一个进程读取数据项 x 的值，那么对该 x 执行的任何后续读操作将总是看到第一个读取的那个值或更新的值</li></ul></li></ul><p><img src="/../assets/dissys/BEzwbA9bmoqQeLx88yfcE5OEnUe.png"></p><h3 id="单调写一致性"><a href="#单调写一致性" class="headerlink" title="单调写一致性"></a>单调写一致性</h3><ul><li>定义<ul><li>一个进程对数据项 x 执行的写操作必须在对该进程对 x 执行的任何后续写操作之前完成<br><img src="/../assets/dissys/KAkEb4KQyow2VuxF9qucLjE4nVb.png"></li></ul></li></ul><h3 id="读写一致性"><a href="#读写一致性" class="headerlink" title="读写一致性"></a>读写一致性</h3><ul><li>定义<ul><li>一个进程对数据项 x 执行一次写操作的结果总是会被该进程对 x 执行的后续读操作看见</li></ul></li></ul><p><img src="/../assets/dissys/QC6SbovcCoKdkuxtCMXcsSOVnSf.png"></p><h3 id="写读一致性"><a href="#写读一致性" class="headerlink" title="写读一致性"></a>写读一致性</h3><ul><li>定义<ul><li>同一个进程对数据项 x 执行的读操作之后的写操作，保证发生在与 x 读取值相同或比之更新的值上</li></ul></li></ul><p><img src="/../assets/dissys/UIihbYByLoh8DKxN1Z4cLcQmnKj.png"></p><h2 id="一致性协议"><a href="#一致性协议" class="headerlink" title="一致性协议"></a>一致性协议</h2><h3 id="持续一致性"><a href="#持续一致性" class="headerlink" title="持续一致性"></a>持续一致性</h3><h3 id="基于主备份的协议"><a href="#基于主备份的协议" class="headerlink" title="基于主备份的协议"></a>基于主备份的协议</h3><p>事实证明，在顺序一致性中，基于主备份的协议比较盛行。在这些协议中，数据存储中的每个数据项有一个相关的主备份，该主备份负责协调在 x 上的写操作。根据主备份是否固定在一个远程服务器上，还是将主备份移动到启动写操作的进程那里之后写操作是否可以在本地执行，可以区分各种主备份协议</p><h4 id="远程写协议"><a href="#远程写协议" class="headerlink" title="远程写协议"></a>远程写协议</h4><ul><li>定义<ul><li>所有读操作和写操作都转发给单个固定的远程服务器的协议</li></ul></li></ul><p><img src="/../assets/dissys/DYmzbJcSNo9qvqxgykvc9MzrnRc.png"></p><ul><li>问题<ul><li>阻塞操作：性能问题，启动更新的进程在被允许继续执行前，可鞥需要等待较长的时间</li><li>非阻塞操作：容错能力。</li></ul></li></ul><h4 id="本地写协议"><a href="#本地写协议" class="headerlink" title="本地写协议"></a>本地写协议</h4><ul><li><p>定义</p><ul><li>其主副本在要执行写操作的进程之间迁移。当某个进程要更新数据项 x 时，先定位 x 的主副本，然后把它移到自己的位置上</li></ul></li><li><p>优点</p><ul><li>可以在本地执行多个连续的写操作，而读操作仍可以访问其本地副本</li></ul></li></ul><p><img src="/../assets/dissys/XlXqbGFH3oUgVLxCJOwciGs6n6f.png"></p><h3 id="复制的写协议"><a href="#复制的写协议" class="headerlink" title="复制的写协议"></a>复制的写协议</h3><p>写操作可以在多个副本上执行，而不是像主备份的副本那样只在一个副本上执行</p><h4 id="主动复制"><a href="#主动复制" class="headerlink" title="主动复制"></a>主动复制</h4><ul><li>定义<ul><li>每个副本有一个相关联的进程，该进程执行更新操作</li></ul></li></ul><h4 id="基于多数表决的协议"><a href="#基于多数表决的协议" class="headerlink" title="基于多数表决的协议"></a>基于多数表决的协议</h4><ul><li><p>定义（基本思想）</p><ul><li>要求客户在读或写一个复制的数据项之前向多个服务器提出请求，并获得他们的许可<ul><li>更新一个文件，必须先联系至少半数加一个服务器，得到他们的认可</li><li>读取一个复制文件，也必须联系至少半数加一个服务器，请求返回该文件的关联版本号，如果版本号一致，那么必定是最新的版本</li></ul></li></ul></li><li><p>Gifford 方案</p><ul><li>一个客户要读取一个具有 N 个副本的文件，必须组织一个读团体$N_R$</li><li>要修改一个文件，客户必须组织一个至少有$N_W$个服务器的写团体</li><li>限制条件<ul><li>$$<br>N_R + N_W &gt; N<br>$$</li><li>$$<br>N_W &gt; N &#x2F; 2<br>$$</li></ul></li><li>第一个条件是为了防止读写操作冲突，第二个限制条件是为了防止读读操作冲突</li></ul></li></ul><p><img src="/../assets/dissys/KG5ebuiEXofXSYxdX9ccSjmZnse.png"></p><h3 id="高速缓存相关性协议"><a href="#高速缓存相关性协议" class="headerlink" title="高速缓存相关性协议"></a>高速缓存相关性协议</h3><h1 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h1><h2 id="容错性概述"><a href="#容错性概述" class="headerlink" title="容错性概述"></a>容错性概述</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>可靠的系统<ul><li>可用性：系统已经准备好，马上就可以使用</li><li>可靠性：系统可以无障碍地持续运行</li><li>安全性：系统在偶然出故障的情况下能正确操作而不会造成任何灾难</li><li>可维护性：发生故障的系统能恢复的难易程度</li></ul></li></ul><h3 id="使用冗余掩盖故障"><a href="#使用冗余掩盖故障" class="headerlink" title="使用冗余掩盖故障"></a>使用冗余掩盖故障</h3><ul><li><p>信息冗余</p><ul><li>添加额外的位可以使错乱的位恢复正常</li></ul></li><li><p>时间冗余</p><ul><li>执行一个动作，如果需要就再次执行</li></ul></li><li><p>物理冗余</p><ul><li>通过添加额外的装备或进程使系统作为一个整体来容忍部分组件的失效或故障成为可能</li></ul></li></ul><h2 id="可靠的客户-服务器通信"><a href="#可靠的客户-服务器通信" class="headerlink" title="可靠的客户-服务器通信"></a>可靠的客户-服务器通信</h2><h3 id="RPC-调用失败"><a href="#RPC-调用失败" class="headerlink" title="RPC 调用失败"></a>RPC 调用失败</h3><ul><li>RPC 调用失败类型以及解决方案<ul><li>客户端无法定位服务器<ul><li>使用特殊的返回码</li><li>抛出异常</li></ul></li><li>客户端发送到服务器的请求消息丢失<ul><li>使用定时器</li></ul></li><li>服务器返回给客户端的响应消息丢失<ul><li>使用定时器</li></ul></li><li>服务器接收到请求后崩溃<ul><li>服务器重启之前不断尝试，这种技术被称为至少一次语义</li><li>立即放弃并回滚，保证 RPC 最多一次执行语义</li><li>客户端什么也不做</li></ul></li><li>客户端发送消息后崩溃<ul><li>孤儿消灭：在客户存根发送 RPC 消息前进行日志记录说明要做什么，重新启动前对日志进行检查然后明确杀死孤儿</li><li>再生：客户端恢复后广播重启新一个轮次的请求，所有与那个客户有关的远程计算都被杀死</li><li>优雅重生：在新时期广播到达时，每台机器都进行检查来查看是否存在远程计算，如果有，就尝试定位它的拥有者，只有当不能找到拥有者时才杀死该计算</li><li>到期：每个 RPC 都有一个标准的时间 T，如果到时间还不能结束，就必须显式地请求另外的时间量</li></ul></li></ul></li></ul><h2 id="分布式提交"><a href="#分布式提交" class="headerlink" title="分布式提交"></a>分布式提交</h2><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>由两个阶段组成，每个阶段又由两部组成。表决阶段的第一阶段由 12 组成，第二阶段是决定阶段由 34 组成。</p><ol><li>协作者向所有的参与者发送一个 <code>VOTE_REQUEST</code> 消息</li><li>当参与者接收到 <code>VOTE_REQUEST</code> 消息时，就向协作者返回一个 <code>VOTE_COMMIT</code> 消息通知协作者它已经准备好本地提交事务中属于它的部分，否则就返回一个 <code>VOTE_ABORT</code> 消息</li><li>协作者收集来自参与者的所有选票。如果所有的参与者都表决要提交事务，那么协作者就进行提交。在这种情况下它向所有的参与者发送一个 <code>GLOBAL_COMMIT</code> 消息。但是，如果有一个参与者表决要取消事务，那么协作者就决定取消事务并多播一个 <code>GLOBAL_ABORT</code> 消息</li><li>每个提交表决的参与者都等待协作者的最后反应。如果参与者收到一个 <code>GLOBAL_COMMIT</code> 消息，那么它就在本地提交事务，否则当接收到一个 <code>GLOBAL_ABORT</code> 消息时，就在本地取消事务</li></ol><h3 id="三阶段提交"><a href="#三阶段提交" class="headerlink" title="三阶段提交"></a>三阶段提交</h3><p>两阶段的一个问题是当协作者崩溃时，参与者不能做出最后的决定。参与者需要在协作者恢复之前保持阻塞</p><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ul><li><p>回退恢复</p><ul><li>将系统从当前的错误状态回到先前的正确状态</li><li>每次记录系统的当前状态时，就成为设置一个检查点</li></ul></li><li><p>前向恢复</p><ul><li>尝试从可以继续执行的某点开始把系统带入一个正确的新状态</li></ul></li></ul><h3 id="检查点"><a href="#检查点" class="headerlink" title="检查点"></a>检查点</h3><ul><li>独立的检查点：进程独立地设置本地检查点</li><li>协调检查点：</li></ul>]]></content>
    
    
    <categories>
      
      <category>南大</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Durable Function</title>
    <link href="/2023/12/05/durable_function/"/>
    <url>/2023/12/05/durable_function/</url>
    
    <content type="html"><![CDATA[<h1 id="Azure-Functions-Durable-Functions"><a href="#Azure-Functions-Durable-Functions" class="headerlink" title="Azure Functions &amp; Durable Functions"></a>Azure Functions &amp; Durable Functions</h1><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><ul><li>前置条件<ul><li>VSCode 安装</li><li>Azure Function 的 VSCode 插件安装</li><li>Azure Function Core Tools 下载</li><li>NodeJS 18 以上</li></ul></li></ul><h3 id="Azure-Function-Code-Tools-下载"><a href="#Azure-Function-Code-Tools-下载" class="headerlink" title="Azure Function Code Tools 下载"></a>Azure Function Code Tools 下载</h3><ol><li>安装微软的包密钥</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor &gt; microsoft.gpg<br>sudo <span class="hljs-built_in">mv</span> microsoft.gpg /etc/apt/trusted.gpg.d/microsoft.gpg<br></code></pre></td></tr></table></figure><ol start="2"><li>设置源</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo sh -c <span class="hljs-string">&#x27;echo &quot;deb [arch=amd64] https://packages.microsoft.com/debian/$(lsb_release -rs | cut -d&#x27;</span>.<span class="hljs-string">&#x27; -f 1)/prod $(lsb_release -cs) main&quot; &gt; /etc/apt/sources.list.d/dotnetdev.list&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>需要做一些小小的修改</p><ul><li>将 20 改为 10，因为我是 debian10 系列的主机</li><li>apricot 改为 buster</li></ul></blockquote><ol start="3"><li>更新源</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br></code></pre></td></tr></table></figure><ol start="4"><li>安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install azure-functions-core-tools-4<br></code></pre></td></tr></table></figure><p><img src="/../assets/durable_function/MicRbJhjio7nALxC2Gtcyvofn5d.png"></p><h3 id="创建本地项目"><a href="#创建本地项目" class="headerlink" title="创建本地项目"></a>创建本地项目</h3><ol><li>使用 VSCode 插件创建 New Project</li><li>选择一个空文件夹</li><li>完成以下设置</li></ol><p><img src="/../assets/durable_function/Qe7jbakHxoDzRHxTyKvc0O6wnFh.png"></p><ol start="4"><li>创建结果</li></ol><p><img src="/../assets/durable_function/WtMyb5p9aokhv7xlPcgcpQt6nj2.png"></p><h3 id="安装-Durable-Functions-包"><a href="#安装-Durable-Functions-包" class="headerlink" title="安装 Durable Functions 包"></a>安装 Durable Functions 包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install durable-functions@preview<br></code></pre></td></tr></table></figure><h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><p>最基本的 Durable Functions 应用有三类基本的函数</p><ul><li><code>Orchestrator function</code>：描述一个编排其他 functions 的 workflow</li><li><code>Activity function</code>：由 <code>orchestrator function</code> 调用，执行工作，可能返回结果</li><li><code>Client function</code>：一个常规的 <code>Azure Function</code> 用来启动一个 <code>orchestrator function</code></li></ul><ol><li>用 VSCode 创建一个 <code>function</code></li><li>完成以下设置</li></ol><p><img src="/../assets/durable_function/PJ5QbDPmJotWDtxtTrJcn4vVnyb.png"></p><ol start="3"><li>可以在 <code>src/functions/hello.js</code> 中看到函数</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash">const &#123; app &#125; = require(<span class="hljs-string">&#x27;@azure/functions&#x27;</span>);<br>const <span class="hljs-built_in">df</span> = require(<span class="hljs-string">&#x27;durable-functions&#x27;</span>);<br><br>const activityName = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><br>df.app.orchestration(<span class="hljs-string">&#x27;helloOrchestrator&#x27;</span>, <span class="hljs-keyword">function</span>* (context) &#123;<br>    const outputs = [];<br>    outputs.push(yield context.df.callActivity(activityName, <span class="hljs-string">&#x27;Tokyo&#x27;</span>));<br>    outputs.push(yield context.df.callActivity(activityName, <span class="hljs-string">&#x27;Seattle&#x27;</span>));<br>    outputs.push(yield context.df.callActivity(activityName, <span class="hljs-string">&#x27;Cairo&#x27;</span>));<br><br>    <span class="hljs-built_in">return</span> outputs;<br>&#125;);<br><br>df.app.activity(activityName, &#123;<br>    handler: (input) =&gt; &#123;<br>        <span class="hljs-built_in">return</span> `Hello, <span class="hljs-variable">$&#123;input&#125;</span>`;<br>    &#125;,<br>&#125;);<br><br>app.http(<span class="hljs-string">&#x27;helloHttpStart&#x27;</span>, &#123;<br>    route: <span class="hljs-string">&#x27;orchestrators/&#123;orchestratorName&#125;&#x27;</span>,<br>    extraInputs: [df.input.durableClient()],<br>    handler: async (request, context) =&gt; &#123;<br>        const client = df.getClient(context);<br>        const body = await request.text();<br>        const instanceId = await client.startNew(request.params.orchestratorName, &#123; input: body &#125;);<br><br>        context.log(`Started orchestration with ID = <span class="hljs-string">&#x27;$&#123;instanceId&#125;&#x27;</span>.`);<br><br>        <span class="hljs-built_in">return</span> client.createCheckStatusResponse(request, instanceId);<br>    &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>在这个例子中</p><ul><li>创建了一个名字为 <code>helloOrchestrator</code> 的编排函数</li><li>创建了一个叫做 <code>hello</code> 的活动函数</li><li>编排函数编排了多个活动函数</li><li>添加了一个 <code>HTTP trigger</code> 函数来启动编排函数</li></ul><h3 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h3><h4 id="本地模拟器"><a href="#本地模拟器" class="headerlink" title="本地模拟器"></a>本地模拟器</h4><ol><li>安装 Azurite 插件</li><li>启动所有 Azurite 服务</li></ol><p><img src="/../assets/durable_function/UOMFbfGUioRuCWxc7Etc87CLnib.png"></p><ol start="3"><li>F5 运行</li></ol><p><img src="/../assets/durable_function/WfwIbz34folArpx86bOcvzjKnie.png"></p><p><img src="/../assets/durable_function/TnKRbw9JxoyA3Jx0lhicaIAWnLf.png"></p><p><img src="/../assets/durable_function/KpzobaVm6oEsCLxbBAuclR2sndc.png"></p><ol start="4"><li>存储状态文件</li></ol><p><img src="/../assets/durable_function/Rk4ybJNjToS0xQxI251cN18wnLh.png"></p><h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><h2 id="实体函数"><a href="#实体函数" class="headerlink" title="实体函数"></a>实体函数</h2><p>实体的行为有点类似于通过消息进行通信的微型服务。 每个实体具有唯一的标识和内部状态（如果存在）。 与服务或对象一样，实体会根据提示执行操作。 执行的操作可能会更新实体的内部状态。 它还可能会调用外部服务并等待响应。 实体使用通过可靠队列隐式发送的消息来与其他实体、业务流程和客户端通信。</p><p>其内部存储的有关某个实体示例的信息如下图所示，其中的 <code>input</code> 字段</p><p><img src="/../assets/durable_function/TFeBbFAveoQZsvxT7pJcRYkXnzc.png"></p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h2 id="可靠执行"><a href="#可靠执行" class="headerlink" title="可靠执行"></a>可靠执行</h2><p>DF 能够确保编排的可靠执行，这是通过使用存储队列来驱动函数的触发以及通过存放执行历史记录来实现的。</p><h3 id="任务关键类"><a href="#任务关键类" class="headerlink" title="任务关键类"></a>任务关键类</h3><p><img src="/./../assets/durable_function/taskkeyclass.png"></p><h4 id="TaskBase"><a href="#TaskBase" class="headerlink" title="TaskBase"></a><code>TaskBase</code></h4><p>所有任务的基类，定义了所有任务的基本状态转移</p><ul><li>在 <code>orchestrator</code> 调用 <code>callActicity</code> 函数的时候，其内部会创建 <code>AtomicTask</code> 类，该类是 <code>TaskBase</code> 的一个子类</li><li>该类的内部存储了 <code>task</code> 的状态 <code>state</code>，表明该任务是 <code>Running</code>、<code>Failed</code> 或者 <code>Completed</code></li><li>当任务（通常是 <code>CompoundTask</code>）调用这个函数时，会判断这个函数是否已经被执行过</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@hidden</span></span><br><span class="hljs-comment"> * Notifies this task&#x27;s parents about its state change.</span><br><span class="hljs-comment"> */</span><br>private <span class="hljs-title function_">propagate</span>(executor?: <span class="hljs-title class_">TaskOrchestrationExecutor</span>): <span class="hljs-keyword">void</span> &#123;<br>    <span class="hljs-keyword">const</span> hasCompleted = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-title class_">TaskState</span>.<span class="hljs-property">Running</span>;<br>    <span class="hljs-keyword">if</span> (hasCompleted &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">parent</span> !== <span class="hljs-literal">undefined</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">parent</span>.<span class="hljs-title function_">handleCompletion</span>(<span class="hljs-variable language_">this</span>, executor);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="DFTask"><a href="#DFTask" class="headerlink" title="DFTask"></a><code>DFTask</code></h4><p>该类简单继承了一下 <code>TaskBase</code>，增加了函数的回调操作</p><h4 id="CompoundTask"><a href="#CompoundTask" class="headerlink" title="CompoundTask"></a><code>CompoundTask</code></h4><p>该类继承 <code>DFTask</code>，包含了多个 <code>TaskBase</code>，也就是维护了多个子任务</p><h3 id="编排关键类"><a href="#编排关键类" class="headerlink" title="编排关键类"></a>编排关键类</h3><p><img src="/../assets/durable_function/orchkeyclass.png"></p><h4 id="Orchestrator"><a href="#Orchestrator" class="headerlink" title="Orchestrator"></a><code>Orchestrator</code></h4><ul><li>负责监听一个编排触发器 <code>DurableOrchestrationBindingInfo</code> 以及处理维护一个上下文 <code>OrchestrationContext</code>，将结果返回给 <code>OrchestratorState</code></li><li>处理的最后将上下文等信息交托给 <code>TaskOrchestrationExecutor</code> 继续执行</li></ul><h4 id="TaskOrchestrationExecutor"><a href="#TaskOrchestrationExecutor" class="headerlink" title="TaskOrchestrationExecutor"></a><code>TaskOrchestrationExecutor</code></h4><p><code>execute</code> 函数负责管理一个编排函数的执行，并且通过历史记录进行重播</p><ol><li>通过历史记录执行编排函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Execute the orchestration, using the history for replay</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> historyEvent <span class="hljs-keyword">of</span> history) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">processEvent</span>(historyEvent);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isDoneExecuting</span>()) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><code>processEvent</code> 函数的主要功能</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript">private <span class="hljs-title function_">processEvent</span>(<span class="hljs-attr">event</span>: <span class="hljs-title class_">HistoryEvent</span>): <span class="hljs-keyword">void</span> &#123;<br>    <span class="hljs-keyword">const</span> eventType = event.<span class="hljs-property">EventType</span>;<br>    <span class="hljs-keyword">switch</span> (eventType) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-title class_">HistoryEventType</span>.<span class="hljs-property">OrchestratorStarted</span>: &#123;<br>            ...<br>        &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-title class_">HistoryEventType</span>.<span class="hljs-property">ContinueAsNew</span>: &#123;<br>           <span class="hljs-comment">// 清除所有编排的状态</span><br>        &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-title class_">HistoryEventType</span>.<span class="hljs-property">ExecutionStarted</span>: &#123;<br>           <span class="hljs-comment">// 继续执行编排函数</span><br>        &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-title class_">HistoryEventType</span>.<span class="hljs-property">EventSent</span>: &#123;<br>           <span class="hljs-comment">// 更新事件ID</span><br>        &#125;<br>        <span class="hljs-attr">default</span>:<br>            <span class="hljs-comment">// 如果当前事件包含了已完成任务的数据，则将该任务封装成一个值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><p><code>tryResumingUserCode</code> 函数</p><ol><li>如果当前执行的任务还在 <code>running</code> 则不能直接执行</li><li>如果整个编排函数执行完成了，则获取其返回值</li><li>如果结果生成器返回了一个 <code>DFTask</code>，那么就表示接下来要执行新的函数</li><li>然后编排函数再以递归的方式执行该函数</li></ol></li><li><p>构建当前的编排状态</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Construct current orchestration state</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">actions</span>: <span class="hljs-title class_">IAction</span>[][] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">actions</span>.<span class="hljs-property">length</span> == <span class="hljs-number">0</span> ? [[]] : [<span class="hljs-variable language_">this</span>.<span class="hljs-property">actions</span>];<br><span class="hljs-keyword">const</span> orchestratorState = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrchestratorState</span>(&#123;<br>    <span class="hljs-attr">isDone</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hasCompletedSuccessfully</span>(),<br>    <span class="hljs-attr">actions</span>: actions,<br>    <span class="hljs-attr">output</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">output</span>,<br>    <span class="hljs-attr">error</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">exception</span>?.<span class="hljs-property">message</span>,<br>    <span class="hljs-attr">customStatus</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-property">customStatus</span>,<br>    <span class="hljs-attr">schemaVersion</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">schemaVersion</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="DurableOrchestrationContext"><a href="#DurableOrchestrationContext" class="headerlink" title="DurableOrchestrationContext"></a><code>DurableOrchestrationContext</code></h4><p>维护函数流的上下文</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Serverless</tag>
      
      <tag>Function orchestration</tag>
      
      <tag>Azure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PXE 批量部署</title>
    <link href="/2023/11/27/PXE/"/>
    <url>/2023/11/27/PXE/</url>
    
    <content type="html"><![CDATA[<h1 id="PXE-批量部署"><a href="#PXE-批量部署" class="headerlink" title="PXE 批量部署"></a>PXE 批量部署</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>PXE（Preboot Execution Environment，预启动执行环境）批量部署是一种通过网络对计算机系统进行安装和配置的技术。这种技术主要用于大规模部署操作系统，特别是在企业或教育机构等环境中，可以同时为多台计算机安装操作系统和软件。下面是 PXE 批量部署的主要步骤和特点：</p><ol><li><strong>启动环境设置</strong>：PXE 利用网络接口卡（NIC）的预引导功能，允许计算机在操作系统加载之前从网络启动。</li><li><strong>TFTP服务器</strong>：PXE 客户端通过网络从 TFTP（Trivial File Transfer Protocol，简单文件传输协议）服务器下载所需的引导文件和操作系统映像。</li><li><strong>DHCP服务</strong>：动态主机配置协议（DHCP）服务器为 PXE 客户端提供网络配置信息，如 IP 地址、子网掩码、默认网关和 TFTP 服务器地址。</li><li><strong>无需物理介质</strong>：与传统的基于 CD&#x2F;DVD 或 USB 驱动器的安装不同，PXE 批量部署不需要物理介质，大大简化了安装过程。</li><li><strong>自动化安装</strong>：PXE 批量部署可以结合脚本和配置文件实现操作系统的自动化安装和配置，减少了手动干预的需求。</li><li><strong>适用于多种操作系统</strong>：PXE 批量部署不限于特定的操作系统，可以用于安装多种不同的操作系统，包括 Windows、Linux 等。</li></ol><p>PXE 批量部署特别适合需要在短时间内为大量计算机安装或重新安装操作系统的情况，大大提高了效率和一致性。</p><h2 id="KVM-与-TCG"><a href="#KVM-与-TCG" class="headerlink" title="KVM 与 TCG"></a>KVM 与 TCG</h2><h3 id="KVM-模式"><a href="#KVM-模式" class="headerlink" title="KVM 模式"></a>KVM 模式</h3><p>KVM（Kernel-based Virtual Machine）是一种基于 Linux 内核的虚拟化技术。它允许你在 Linux 系统上运行多个带有自己操作系统的虚拟机，这些虚拟机可以是 Linux、Windows 或其他任何支持 x86 架构的操作系统。KVM 模式的特点包括：</p><ol><li><strong>硬件辅助虚拟化</strong>：KVM 利用现代处理器的硬件虚拟化支持（如 Intel VT 或 AMD-V）来提高性能。</li><li><strong>内核级运行</strong>：作为 Linux 内核的一部分运行，提供高效的性能和优良的集成。</li><li><strong>支持多种客户机操作系统</strong>：可以在 KVM 上运行各种操作系统。</li></ol><h3 id="TCG-模式"><a href="#TCG-模式" class="headerlink" title="TCG 模式"></a>TCG 模式</h3><p>TCG（Tiny Code Generator）是 QEMU（一种常用的虚拟化软件）使用的软件模拟模式。当硬件不支持虚拟化或者没有启用硬件虚拟化功能时，QEMU 会使用 TCG 来模拟 CPU，这意味着 CPU 指令是在软件层面上被模拟的。TCG 模式相比 KVM 模式性能较低，但它可以在不支持硬件虚拟化的环境下工作。</p><h3 id="如何检查系统是否支持-KVM"><a href="#如何检查系统是否支持-KVM" class="headerlink" title="如何检查系统是否支持 KVM"></a>如何检查系统是否支持 KVM</h3><p>要检查您的 Linux 系统是否支持 KVM，您可以使用以下命令：</p><ol><li><strong>检查<strong><strong>CPU</strong></strong>是否支持硬件虚拟化</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">egrep -c <span class="hljs-string">&#x27;(vmx|svm)&#x27;</span> /proc/cpuinfo<br></code></pre></td></tr></table></figure><p>如果这个命令返回的数字大于0，那么您的CPU支持硬件虚拟化（vmx针对Intel处理器，svm针对AMD处理器）。</p><ol start="2"><li><strong>检查<strong><strong>KVM</strong></strong>内核模块是否已加载</strong>：</li></ol><ul><li>对于Intel处理器：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsmod | grep kvm_intel<br></code></pre></td></tr></table></figure><ul><li>对于 AMD 处理器：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsmod | grep kvm_amd<br></code></pre></td></tr></table></figure> 如果这些命令返回了结果，表明相应的KVM模块已经被加载到内核中。</li></ul><ol><li><p><strong>检查是否安装了<strong><strong>KVM</strong></strong>工具：</strong></p><p>可以通过检查<code>qemu-kvm</code>包是否安装来确定系统是否配置了KVM。</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kvm-ok<br></code></pre></td></tr></table></figure><p>如果您的系统安装了 <code>cpu-checker</code> 包，<code>kvm-ok</code> 命令会告诉您系统是否准备好运行 KVM 虚拟机。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><h3 id="以命令行的方式启动虚拟机镜像"><a href="#以命令行的方式启动虚拟机镜像" class="headerlink" title="以命令行的方式启动虚拟机镜像"></a>以命令行的方式启动虚拟机镜像</h3><p>通过命令行启动虚拟机的镜像通常涉及到使用虚拟化工具，例如 QEMU 或 KVM。以下是使用 QEMU&#x2F;KVM 通过命令行启动一个虚拟机镜像的基本步骤：</p><h4 id="使用-QEMU-启动虚拟机"><a href="#使用-QEMU-启动虚拟机" class="headerlink" title="使用 QEMU 启动虚拟机"></a>使用 QEMU 启动虚拟机</h4><ol><li><strong>安装 QEMU</strong>（如果尚未安装）：</li></ol><p>在 Ubuntu 或 Debian 系统上，您可以使用以下命令安装 QEMU：</p><ol><li><p><strong>启动虚拟机</strong>：</p><p>使用以下命令启动虚拟机镜像：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">qemu-system-x86_64 -hda /path/to/your/vm/image.img<br></code></pre></td></tr></table></figure><ul><li><code>qemu-system-x86_64</code> 是 QEMU 用于 x86_64 架构的模拟器。</li><li><code>-hda</code> 指定硬盘镜像的位置，这里是您的虚拟机镜像的路径。</li></ul><ol start="2"><li><strong>其他选项</strong>：</li></ol><ul><li>您可以添加 <code>-m</code> 参数来指定分配给虚拟机的内存量。例如，<code>-m 2048</code> 分配 2GB 内存。</li><li><code>-cdrom</code> 参数可以用来指定一个 ISO 镜像以模拟光驱。例如，<code>-cdrom /path/to/cdrom/image.iso</code>。</li></ul><h1 id="预备工具"><a href="#预备工具" class="headerlink" title="预备工具"></a>预备工具</h1><h2 id="准备-Ubuntu-镜像"><a href="#准备-Ubuntu-镜像" class="headerlink" title="准备 Ubuntu 镜像"></a>准备 Ubuntu 镜像</h2><p>从 <a href="https://mirrors.nju.edu.cn/ubuntu-releases/22.04/ubuntu-22.04.3-live-server-amd64.iso">https://mirrors.nju.edu.cn/ubuntu-releases/22.04/ubuntu-22.04.3-live-server-amd64.iso</a> 下下载.iso 镜像，举个例子，放到 <code>~/Downloads</code> 目录下</p><h2 id="DHCP-服务器"><a href="#DHCP-服务器" class="headerlink" title="DHCP 服务器"></a>DHCP 服务器</h2><ol><li>配置网络适配器</li></ol><p>由于未来的虚拟机要在 <code>192.168.1.n</code> 的网络环境下进行通信，我们需要建造一个网桥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo brctl addbr br0<br>sudo ifup br0<br>sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> br0 up<br></code></pre></td></tr></table></figure><ol><li>编辑 <code>/etc/network/interfaces</code> 文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">auto br0<br>iface br0 inet static<br>    address 192.168.1.1<br>    netmask 255.255.255.0<br>    network 192.168.1.0<br>    broadcast 192.168.1.255<br></code></pre></td></tr></table></figure><ol start="2"><li>安装 <code>dhcp</code> 服务器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install isc-dhcp-server<br></code></pre></td></tr></table></figure><ol start="3"><li>配置 <code>dhcp</code> 服务器<br>编辑 DHCP 服务器的配置文件 <code>/etc/dhcp/dhcpd.conf</code>，将配置文件加入到里头</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">subnet 192.168.1.0 netmask 255.255.255.0 &#123;<br>    range 192.168.1.10 192.168.1.100;<br>    option domain-name-servers 8.8.8.8;<br>    option routers 192.168.1.1;<br>    option broadcast-address 192.168.1.255;<br>    default-lease-time 600;<br>    max-lease-time 7200;<br>&#125;<br><br>allow booting;<br>allow bootp;<br><br>next-server 192.168.1.1;<br>filename <span class="hljs-string">&quot;pxelinux.0&quot;</span>;<br></code></pre></td></tr></table></figure><p>这个配置指定了 DHCP 服务管理的子网、IP 地址范围、DNS 服务器地址、默认路由器（网关）地址和广播地址。另外 <code>filename</code> 定义了 <code>tftp</code> 服务器的相关配置，在下列文档中会提到</p><ol start="4"><li>指定网络接口</li></ol><p>在 <code>/etc/default/isc-dhcp-server</code> 文件中指定 <code>DHCP</code> 服务应该监听的网络接口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">INTERFACESv4=<span class="hljs-string">&quot;br0&quot;</span><br></code></pre></td></tr></table></figure><ol start="5"><li>使用 <code>systemctl</code> 启动 <code>dhcp</code> 服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl start isc-dhcp-server.service<br><span class="hljs-comment"># 检查启动状态</span><br>sudo systemctl status isc-dhcp-server.service<br></code></pre></td></tr></table></figure><h2 id="TFTP-服务器"><a href="#TFTP-服务器" class="headerlink" title="TFTP 服务器"></a>TFTP 服务器</h2><ol><li>下载 <code>tftp</code> 服务器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install tftpd-hpa<br></code></pre></td></tr></table></figure><ol start="2"><li>配置 <code>tftp</code> 服务器</li></ol><p>编辑 <code>/etc/default/tftp-hpa</code> 文件为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">TFTP_USERNAME=<span class="hljs-string">&quot;tftp&quot;</span><br>TFTP_DIRECTORY=<span class="hljs-string">&quot;/var/lib/tftpboot&quot;</span><br>TFTP_ADDRESS=<span class="hljs-string">&quot;0.0.0.0:69&quot;</span><br>TFTP_OPTIONS=<span class="hljs-string">&quot;--secure&quot;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>设置 <code>tftp</code> 根目录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> /var/lib/tftpboot<br>sudo <span class="hljs-built_in">chown</span> tftp:tftp /var/lib/tftpboot<br>sudo <span class="hljs-built_in">chmod</span> -R 755 /var/lib/tftpboot<br></code></pre></td></tr></table></figure><ol start="4"><li>设置 <code>qemu</code> 安装时的引导文件</li></ol><p>编辑 <code>/var/lib/tftpboot/pxelinux.cfg/default</code> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">DEFAULT linux<br>LABEL linux<br>  SAY <span class="hljs-string">&quot;Booting the Ubuntu 22.04 Installer...&quot;</span><br>  KERNEL vmlinuz<br>  INITRD initrd<br>  APPEND root=/dev/ram0 ramdisk_size=1500000  ip=dhcp url=http://192.168.1.1/ubuntu-22.04.3-live-server-amd64.iso autoinstall ds=nocloud-net s=http://192.168.1.1/autoinstall/ cloud-config-url=http://192.168.1.1/autoinstall/user-data console=tty1 console=ttyS0 ---<br></code></pre></td></tr></table></figure><ul><li><p><code>DEFAULT linux</code>: 这指定了默认的标签或菜单项，当 PXE 引导时，如果没有用户交互，将自动选择这个菜单项。</p></li><li><p><code>LABEL linux</code>: 这定义了一个新的标签或菜单项，可以通过用户输入或默认设置被选择。</p></li><li><p><code>SAY &quot;Booting the Ubuntu 22.04 Installer...&quot;</code>: 这将在引导时在屏幕上打印一条消息，指示正在启动安装程序。</p></li><li><p><code>KERNEL vmlinuz</code>: 这指定了内核文件的位置，该文件是必须由 TFTP 服务器提供的，以便客户端下载并启动。</p></li><li><p><code>INITRD initrd</code>: 这指定了初始化 RAM 磁盘的位置，这也是由 TFTP 服务器提供，包含了内核在启动过程中所需的所有驱动程序和工具。</p></li><li><p><code>APPEND</code>: 这一行提供了内核启动时所需的额外参数：</p><ul><li><code>root=/dev/ram0</code>: 使用 RAM 磁盘作为根文件系统。</li><li><code>ramdisk_size=1500000</code>: 设置 RAM 磁盘的大小（以千字节为单位）。</li><li><code>ip=dhcp</code>: 通过 DHCP 获得 IP 地址。</li><li><code>url=http://192.168.1.1/ubuntu-22.04.3-live-server-amd64.iso</code>: 指定 Ubuntu 安装 ISO 文件的位置，PXE 客户端将从这个 URL 下载 ISO 并进行安装。</li><li><code>autoinstall</code>: 指定使用 autoinstall 方法进行无人值守安装。</li><li><code>ds=nocloud-net s=http://192.168.1.1/autoinstall/</code>: 指定 autoinstall 配置文件的位置，它告诉安装程序如何进行无人值守安装。</li><li><code>cloud-config-url=http://192.168.1.1/autoinstall/user-data</code>: 指定用户数据文件的 URL，它包含了安装过程中所需的用户和系统配置。</li><li><code>console=tty1 console=ttyS0</code>: 指定控制台输出应该重定向到哪里，<code>tty1</code> 是第一个虚拟终端，<code>ttyS0</code> 是第一个串行端口。</li></ul></li></ul><blockquote><p>以上 http 的内容将在 Apache 服务器的配置中实现</p></blockquote><ol start="5"><li>放置资源文件</li></ol><p>从刚才的 <code>.iso</code> 镜像中拿取响应的资源文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> -p /mnt/ubuntu<br>sudo mount -o loop ~/Downloads/ubuntu-22.04.3-live-server-amd64.iso /mnt/ubuntu<br>sudo <span class="hljs-built_in">cp</span> /mnt/casper/vmlinuz /var/lib/tftpboot/<br>sudo <span class="hljs-built_in">cp</span> /mnt/casper/initrd /var/lib/tftpboot/<br>sudo umount /mnt/ubuntu<br></code></pre></td></tr></table></figure><ol start="6"><li>启动 <code>tftp</code> 服务</li></ol><p>配置完成后，启动 <code>tftp</code> 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl start tftp-hpa.service<br>sudo systemctl status tftp-hpa.service<br></code></pre></td></tr></table></figure><h2 id="Apache-服务器"><a href="#Apache-服务器" class="headerlink" title="Apache 服务器"></a>Apache 服务器</h2><ol><li>安装 <code>Apache</code> 服务器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install apache2<br></code></pre></td></tr></table></figure><ol start="2"><li>配置 <code>Apache</code> 服务器</li></ol><p>编辑 <code>/etc/apache2/apache2.conf</code> 文件，在最后一行指定 <code>Apache</code> 服务器监听的位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">serverName 192.168.1.1<br></code></pre></td></tr></table></figure><ol start="3"><li>启动 <code>Apache</code> 服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl start apache2<br></code></pre></td></tr></table></figure><ol start="4"><li>开机自启动</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> apache2<br></code></pre></td></tr></table></figure><ol start="5"><li>检查 <code>Apache</code> 服务状态</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl status apache2<br></code></pre></td></tr></table></figure><ol start="6"><li>放置资源文件<ul><li>首先将.iso 镜像放到 <code>/var/www/html</code> 中</li><li>放 <code>autoinstall</code> 目录</li></ul></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> -p /var/www/html/autoinstall<br>sudo <span class="hljs-built_in">touch</span> /var/www/html/autoinstall/meta-data<br>sudo <span class="hljs-built_in">chmod</span> -R 777 /var/www/html/autoinstall<br></code></pre></td></tr></table></figure><ul><li><p>放置初始化脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> -p /var/www/html/init<br>sudo <span class="hljs-built_in">cp</span> init/install.sh /var/www/html/init<br>sudo <span class="hljs-built_in">cp</span> init/http_server.py /var/www/html/init<br>sudo <span class="hljs-built_in">cp</span> init/http_server.service /var/www/html/init<br></code></pre></td></tr></table></figure></li><li><p>放置ssh文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> -p /var/www/html/ssh<br>sudo <span class="hljs-built_in">cp</span> ~/.ssh/id_ed25519 /var/www/html/ssh<br>sudo <span class="hljs-built_in">cp</span> ~/.ssh/id_ed25519.pub /var/www/html/ssh<br></code></pre></td></tr></table></figure></li></ul><h1 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h1><h2 id="构建虚拟机镜像"><a href="#构建虚拟机镜像" class="headerlink" title="构建虚拟机镜像"></a>构建虚拟机镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash build.sh 10<br></code></pre></td></tr></table></figure><p>该过程会调用 <code>user_data.py</code> 自动生成 <code>user-data</code> 放到 <code>Apache</code> 服务器的目录下，然后生成 <code>vm-10</code> 目录</p><h2 id="启动虚拟机"><a href="#启动虚拟机" class="headerlink" title="启动虚拟机"></a>启动虚拟机</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash vm-10 run.sh<br></code></pre></td></tr></table></figure><p>启动后安装相应工具，安装脚本已经预先安装在了 <code>/install.sh</code> 下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash /install.sh<br></code></pre></td></tr></table></figure><h2 id="测试连通性"><a href="#测试连通性" class="headerlink" title="测试连通性"></a>测试连通性</h2><ol><li>通过主机请求虚拟机的端口获取虚拟机的机器编号</li><li>测试虚拟机是否能够 ping 通主机</li><li>测试主机是否能够 ping 通虚拟机</li><li>测试虚拟机之间能否互相 ping 通</li></ol><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="网桥问题"><a href="#网桥问题" class="headerlink" title="网桥问题"></a>网桥问题</h2><ul><li><p>问题描述</p><ul><li>要启动虚拟机的时候需要用到 <code>br0</code> 作为网桥，使用 <code>helper</code> 参数前需要先 allow 一下 br0</li><li>启动脚本访问该文件的时候需要 <code>root</code> 权限</li></ul></li><li><p>解决方案</p><ul><li>编辑 <code>/etc/qemu/bridge.conf</code> 为</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">allow br0<br></code></pre></td></tr></table></figure><ul><li>为<code>/usr/lib/qemu/qemu-bridge-helper</code>添加权限<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chmod</span> u+s /usr/lib/qemu/qemu-bridge-helper<br></code></pre></td></tr></table></figure></li></ul><h2 id="MAC-地址重复"><a href="#MAC-地址重复" class="headerlink" title="MAC 地址重复"></a>MAC 地址重复</h2><ul><li>问题描述<ul><li>在启动多台虚拟机后，默认的多台虚拟机的 mac 地址会有重复</li></ul></li><li>解决方案<ul><li>在启动时添加一个 mac 地址的参数，其中 14 表示虚拟机 20</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mac=08:00:27:02:14:E7<br></code></pre></td></tr></table></figure><h2 id="虚拟机之间不能ping通"><a href="#虚拟机之间不能ping通" class="headerlink" title="虚拟机之间不能ping通"></a>虚拟机之间不能ping通</h2><ul><li><p>问题描述：</p><ul><li>虚拟机可以ping通主机</li><li>主机可以ping通虚拟机</li><li>虚拟机之间不能互相ping通</li><li>虚拟机查看<code>arp -n</code>可以看到另一台虚拟机的IP地址</li><li>虚拟机之间可以通过<code>arping</code>连接</li></ul></li><li><p>解决方案</p><ul><li>这种情况下大概率是主机的防火墙问题，查看了一下<code>iptables</code>，发现里头的INPUT以及OUTPUT都是ACCEPT的，但是FORWARD选项是DROP的，这样表示，输入输出都没问题，但是禁止转发，通过下列命令进行修正</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo iptables -P FORWARD ACCEPT<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>南大</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shell</tag>
      
      <tag>Linux</tag>
      
      <tag>Qemu</tag>
      
      <tag>DHCP</tag>
      
      <tag>TFTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes 学习笔记</title>
    <link href="/2023/10/29/kubernetes/"/>
    <url>/2023/10/29/kubernetes/</url>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes-概述"><a href="#Kubernetes-概述" class="headerlink" title="Kubernetes 概述"></a>Kubernetes 概述</h1><ul><li>k8s 官网：<a href="https://kubernetes.io/">https://kubernetes.io/</a></li></ul><p>Kubernetes 又被叫做 k8s，是一个用于自动化部署、自动扩容以及容器化应用管理的开源系统</p><h1 id="kubernetes-搭建"><a href="#kubernetes-搭建" class="headerlink" title="kubernetes 搭建"></a><code>kubernetes</code> 搭建</h1><p>使用阿里云的镜像构建 k8s</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https<br>curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add -<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/OQ4Ib3kX8oPLdMxC3MZcdZmmnNf.png"></p><p>之后将阿里云的镜像地址写到 sources.list 当中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/apt/sources.list.d/kubernetes.list<br><br><span class="hljs-comment"># 写入下列内容</span><br>deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main<br></code></pre></td></tr></table></figure><p>退出后更新软件包，下载 k8s</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get install -y kubelet kubeadm kubectl<br></code></pre></td></tr></table></figure><h1 id="kubernetes-工具搭建"><a href="#kubernetes-工具搭建" class="headerlink" title="kubernetes 工具搭建"></a><code>kubernetes</code> 工具搭建</h1><p>通过上述流程其实已经安装好了 <code>kubelet</code>、<code>kubeadm</code> 以及 <code>kubectl</code>。如果没有安装就参照下列文档</p><h2 id="kubectl"><a href="#kubectl" class="headerlink" title="kubectl"></a><code>kubectl</code></h2><h3 id="kubectl-安装"><a href="#kubectl-安装" class="headerlink" title="kubectl 安装"></a><code>kubectl</code> 安装</h3><p>kubectl 是一个能够在 k8s 集群中运行命令的工具</p><ol><li>下载最新的 <code>kubectl</code> 发行版</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -LO <span class="hljs-string">&quot;https://dl.k8s.io/release/<span class="hljs-subst">$(curl -L -s https://dl.k8s.io/release/stable.txt)</span>/bin/linux/amd64/kubectl&quot;</span><br></code></pre></td></tr></table></figure><ol><li>验证 <code>kubectl</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -LO <span class="hljs-string">&quot;https://dl.k8s.io/<span class="hljs-subst">$(curl -L -s https://dl.k8s.io/release/stable.txt)</span>/bin/linux/amd64/kubectl.sha256&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(cat kubectl.sha256)</span>  kubectl&quot;</span> | <span class="hljs-built_in">sha256sum</span> --check<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/FKQlbkSaaotYn8xgznecx9pqnyg.png"></p><ol><li>安装 kubectl</li></ol><p>由于我不想安装在根目录中（考虑到系统应当保持对普通用户的最小权限），因此将 <code>kubectl</code> 安装为普通用户模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p ~/.local/bin/<br><span class="hljs-built_in">mv</span> ./kubectl ~/.local/bin/<br></code></pre></td></tr></table></figure><ol><li>验证 <code>kubectl</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl version --client<br><br>kubectl version --client --output=yaml<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/CmacbNQiVowWpwxOpDJcosoenHc.png"></p><h3 id="kubectl-配置"><a href="#kubectl-配置" class="headerlink" title="kubectl 配置"></a><code>kubectl</code> 配置</h3><p>为了使得 <code>kubectl</code> 能够找到并且感知一个 k8s 集群，它需要一个 <code>kubeconfig file</code>，其在使用 <code>kube-up.sh</code> 创建一个集群或者成功部署一个 <code>Minikube</code> 集群的时候会自动创建。默认情况下，<code>kubeconfig</code> 配置会放在 <code>~/.kube/config</code></p><ol><li>通过集群的状态可以检查 <code>kubectl</code> 是否已经配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl cluster-info<br></code></pre></td></tr></table></figure><h2 id="kubeadm"><a href="#kubeadm" class="headerlink" title="kubeadm"></a><code>kubeadm</code></h2><h3 id="配置-CA-证书"><a href="#配置-CA-证书" class="headerlink" title="配置 CA 证书"></a>配置 CA 证书</h3><ol><li>下载 <code>easyrsa3</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -LO https://dl.k8s.io/easy-rsa/easy-rsa.tar.gz<br>tar xzf easy-rsa.tar.gz<br><span class="hljs-built_in">cd</span> easy-rsa-master/easyrsa3<br>./easyrsa init-pki<br></code></pre></td></tr></table></figure><ol><li>生成一个新的 CA</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./easyrsa --batch <span class="hljs-string">&quot;--req-cn=<span class="hljs-variable">$&#123;MASTER_IP&#125;</span>@`date +%s`&quot;</span> build-ca nopass<br></code></pre></td></tr></table></figure><ol><li>生成服务器证书和密钥</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">./easyrsa --subject-alt-name=<span class="hljs-string">&quot;IP:<span class="hljs-variable">$&#123;MASTER_IP&#125;</span>,&quot;</span>\<br><span class="hljs-string">&quot;IP:<span class="hljs-variable">$&#123;MASTER_CLUSTER_IP&#125;</span>,&quot;</span>\<br><span class="hljs-string">&quot;DNS:kubernetes,&quot;</span>\<br><span class="hljs-string">&quot;DNS:kubernetes.default,&quot;</span>\<br><span class="hljs-string">&quot;DNS:kubernetes.default.svc,&quot;</span>\<br><span class="hljs-string">&quot;DNS:kubernetes.default.svc.cluster,&quot;</span>\<br><span class="hljs-string">&quot;DNS:kubernetes.default.svc.cluster.local&quot;</span> \<br>--days=10000 \<br>build-server-full server nopass<br></code></pre></td></tr></table></figure><ol><li>拷贝 <code>pki/ca.crt</code>, <code>pki/issued/server.crt</code>, and <code>pki/private/server.key</code> 到特定目录.</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">dydy@dydy-PC:~/Downloads/easy-rsa-master/easyrsa3/pki$ sudo <span class="hljs-built_in">cp</span> ./ca.crt /etc/kubernetes/pki/ca.crt<br>dydy@dydy-PC:~/Downloads/easy-rsa-master/easyrsa3/pki$ sudo <span class="hljs-built_in">cp</span> ./private/ca.key /etc/kubernetes/pki/ca.key<br></code></pre></td></tr></table></figure><h2 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a><code>kubelet</code></h2><h3 id="通过配置文件设置-kubelet-参数"><a href="#通过配置文件设置-kubelet-参数" class="headerlink" title="通过配置文件设置 kubelet 参数"></a><a href="https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/">通过配置文件设置</a> <code>kubelet</code> <a href="https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/">参数</a></h3><ol><li>创建配置文件</li></ol><p>我们在 <code>kubelet</code> 看得到的地方创建一个配置文件，以下是一个示例</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kubelet.config.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">KubeletConfiguration</span><br><span class="hljs-attr">address:</span> <span class="hljs-string">&quot;192.168.0.8&quot;</span><br><span class="hljs-attr">port:</span> <span class="hljs-number">20250</span><br><span class="hljs-attr">serializeImagePulls:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">evictionHard:</span><br>    <span class="hljs-attr">memory.available:</span>  <span class="hljs-string">&quot;200Mi&quot;</span><br></code></pre></td></tr></table></figure><ol><li>通过配置文件启动进程</li></ol><h1 id="kubernetes-容器运行时-container-runtimes"><a href="#kubernetes-容器运行时-container-runtimes" class="headerlink" title="kubernetes 容器运行时(container runtimes)"></a><code>kubernetes</code> 容器运行时(container runtimes)</h1><p>本章节主要讲述了设置结点的相关任务</p><p>主要的安装软件包括</p><ul><li><code>containerd</code></li><li><code>CRI-O</code></li><li><code>Docker Engine</code></li><li><code>Mirantis Container Runtime</code></li></ul><h2 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h2><ol><li>转发 IPV4 并且让 <code>iptables</code> 能够看到桥接流量</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /etc/modules-load.d/<br><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">EOF | sudo tee ./k8s.conf</span><br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/UF6dbZiWwonpkOxXnNkcMXB5nGg.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo modprobe overlay<br>sudo modprobe br_netfilter<br><br><span class="hljs-comment"># sysctl params required by setup, params persist across reboots</span><br><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF | sudo tee /etc/sysctl.d/k8s.conf</span><br><span class="hljs-string">net.bridge.bridge-nf-call-iptables  = 1</span><br><span class="hljs-string">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="hljs-string">net.ipv4.ip_forward                 = 1</span><br><span class="hljs-string">EOF</span><br><span class="hljs-comment"># Apply sysctl params without rebootsudo sysctl --system</span><br><br>sudo sysctl --system<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/AvQDb0KqEon2TlxQWuLcdlo8nvh.png"></p><p>验证 <code>br_netfilter</code> 以及 <code>overlay</code> 模块是否已经被加载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsmod | grep br_netfilter<br>lsmod | grep overlay<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/NoJvbLRguoqrVuxZP5RcaKfInxb.png"></p><p>验证 <code>net.bridge.bridge-nf-call-iptables</code>, <code>net.bridge.bridge-nf-call-ip6tables</code>, and <code>net.ipv4.ip_forward</code> 这些系统变量都被设置为 1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sysctl net.bridge.bridge-nf-call-iptables net.bridge.bridge-nf-call-ip6tables net.ipv4.ip_forward<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/Vc21bvHmlonR0NxUCMOc7j6Anqc.png"></p><h2 id="cgroup-驱动"><a href="#cgroup-驱动" class="headerlink" title="cgroup 驱动"></a><code>cgroup</code> 驱动</h2><p>在 Linux 系统下，控制组（<code>control groups</code>）被用来管理附加在进程上的资源</p><p><code>kubelet</code> 以及我们所需要安装的工具都需要通过实现 <code>control groups</code> 来促使 <code>pods &amp; containers</code> 的资源管理以及设置资源限制。为了通过 <code>control groups</code> 实现，<code>kubelet</code> 以及容器运行时需要使用 <code>cgroup drivers</code>。需要强调的是 <code>kubelet</code> 以及容器运行时使用的是相同的 <code>cgroup</code> 驱动以及拥有着相同的配置</p><ul><li><code>cgroupfs</code></li><li><code>systemd</code></li></ul><h3 id="cgroupfs-驱动"><a href="#cgroupfs-驱动" class="headerlink" title="cgroupfs 驱动"></a><code>cgroupfs</code> 驱动</h3><p><code>cgroupfs driver</code> 是默认的 <code>kubelet cgroup</code> 驱动。通过使用 <code>cgroupfs</code> 驱动，<code>kubelet</code> 以及容器运行时就可以直接实现 <code>cgroup</code> 文件系统来配置 <code>cgroups</code></p><p><code>cgroups</code> 驱动在 <code>systemd</code> 已经在系统最开始就安装的情况下是不推荐的，因为 <code>systemd</code> 希望系统中只有一个单独的 <code>cgroup</code> 管理者</p><h3 id="systemd-cgroup-驱动"><a href="#systemd-cgroup-驱动" class="headerlink" title="systemd cgroup 驱动"></a><code>systemd</code> <code>cgroup</code> 驱动</h3><p>前面我们提到，当系统初始化时已经使用了 <code>systemd</code> 作为系统资源的管理者时，便不再使用 <code>cgroupfs</code>，否则系统将会有两个不同的资源管理器，带来的后果如下</p><blockquote><p>Two <code>cgroup</code> managers result in two views of the available and in-use resources in the system. In some cases, nodes that are configured to use <code>cgroupfs</code> for the kubelet and container runtime, but use <code>systemd</code> for the rest of the processes become unstable under resource pressure.</p></blockquote><p>因此当 <code>systemd</code> 在系统初始化时已经被用于管理系统资源，我们使用 <code>systemd</code> 作为 <code>kubelet</code> 以及容器运行时的 <code>cgroup</code> 驱动。</p><p>为了将 <code>systemd</code> 设置为 <code>cgroup</code> 驱动，通过编辑 <code>KubeletConfiguration</code> 选项来设置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kubelet.config.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">KubeletConfiguration</span><br><span class="hljs-string">...</span><br><span class="hljs-attr">cgroupDriver:</span> <span class="hljs-string">systemd</span><br></code></pre></td></tr></table></figure><h3 id="将-systemd-驱动迁移至-kubdeam-管理的集群"><a href="#将-systemd-驱动迁移至-kubdeam-管理的集群" class="headerlink" title="将 systemd 驱动迁移至 kubdeam 管理的集群"></a>将 <code>systemd</code> 驱动迁移至 <code>kubdeam</code> 管理的集群</h3><p>本章节主要介绍如何通过默认的 <code>systemd</code> 驱动建立不同的容器运行时</p><h4 id="配置-kubelet-的-cgroup-驱动"><a href="#配置-kubelet-的-cgroup-驱动" class="headerlink" title="配置 kubelet 的 cgroup 驱动"></a>配置 <code>kubelet</code> 的 <code>cgroup</code> 驱动</h4><p><code>kubeadm</code> 允许用户在使用 <code>kubeadm init</code> 时传入一个 <code>kubeletConfiguration</code> 数据结构。这个结构可以包括 <code>cgroupDriver</code> 字段来控制 <code>kubelet</code> 的 <code>cgroup</code> 驱动</p><p>一个最简单的配置字段的例子</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># kubeadm-config.yaml</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterConfiguration</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kubeadm.k8s.io/v1beta3</span><br><span class="hljs-attr">kubernetesVersion:</span> <span class="hljs-string">v1.21.0</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">KubeletConfiguration</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kubelet.config.k8s.io/v1beta1</span><br><span class="hljs-attr">cgroupDriver:</span> <span class="hljs-string">systemd</span><br></code></pre></td></tr></table></figure><p>可以通过以下的启动命令进行传递</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubeadm init --config kubeadm-config.yaml<br></code></pre></td></tr></table></figure><h2 id="容器运行时"><a href="#容器运行时" class="headerlink" title="容器运行时"></a>容器运行时</h2><h3 id="containerd"><a href="#containerd" class="headerlink" title="containerd"></a><code>containerd</code></h3><blockquote><p><strong>FAQ</strong>: For Kubernetes, do I need to download <code>cri-containerd-(cni-)&lt;VERSION&gt;-&lt;OS-&lt;ARCH&gt;.tar.gz</code> too?<br><strong>Answer</strong>: No.<br>As the Kubernetes CRI feature has been already included in <code>containerd-&lt;VERSION&gt;-&lt;OS&gt;-&lt;ARCH&gt;.tar.gz</code>, you do not need to download the <code>cri-containerd-....</code> archives to use CRI.<br>The <code>cri-containerd-...</code> archives are <a href="https://github.com/containerd/containerd/blob/main/RELEASES.md#deprecated-features">deprecated</a>, do not work on old Linux distributions, and will be removed in containerd 2.0.</p><p>…非常抽象</p></blockquote><ol><li>安装 <code>containerd</code></li></ol><p>通过<u><a href="https://github.com/containerd/containerd/releases">https://github.com/containerd/containerd/releases</a></u> 下载对应版本的 <code>containerd</code> 并解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo tar Cxzvf /usr/local/ containerd-1.6.24-linux-amd64.tar.gz<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/TlWmbH8bMoDbS0xPUNqcfw8wnsd.png"></p><p><strong>systemd</strong></p><p>为了使用 <code>systemd</code> 启动 <code>containerd</code>，我们应该通过 <a href="https://raw.githubusercontent.com/containerd/containerd/main/containerd.service">https://raw.githubusercontent.com/containerd/containerd/main/containerd.service</a> 下载配置文件到 <code>/usr/local/lib/systemd/system</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dydy@dydy-PC:/usr/local/lib/systemd/system$ curl https://erd/main/containerd.service | sudo <span class="hljs-built_in">tee</span> /usr/local/lib/systemd/system/containerd.service<br></code></pre></td></tr></table></figure><p>然后运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl daemon-reload<br>systemctl <span class="hljs-built_in">enable</span> --now containerd<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/QkoxbqXUioGzWnxwd7ocef0LnRc.png"></p><ol><li>安装 <code>runc</code></li></ol><p>从 <a href="https://github.com/opencontainers/runc/releases">https://github.com/opencontainers/runc/releases</a> 下载二进制文件，然后执行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo install -m 755 runc.amd64 /usr/local/sbin/runc<br></code></pre></td></tr></table></figure><ol><li>安装 CNI 插件</li></ol><p>从 <a href="https://github.com/containernetworking/plugins/releases">https://github.com/containernetworking/plugins/releases</a> 下载二进制文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> -p /opt/cni/bin/<br>sudo tar Cxzvf /opt/cni/bin/ cni-plugins-linux-amd64-v1.3.0.tgz<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/L2bxbVLLCorH2hx1AgQcseELngh.png"></p><p>安装完成后，会在 <code>/etc/containerd/config.toml</code> 当中看到配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#   Copyright 2018-2022 Docker Inc.</span><br><br><span class="hljs-comment">#   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="hljs-comment">#   you may not use this file except in compliance with the License.</span><br><span class="hljs-comment">#   You may obtain a copy of the License at</span><br><br><span class="hljs-comment">#       http://www.apache.org/licenses/LICENSE-2.0</span><br><br><span class="hljs-comment">#   Unless required by applicable law or agreed to in writing, software</span><br><span class="hljs-comment">#   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="hljs-comment">#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="hljs-comment">#   See the License for the specific language governing permissions and</span><br><span class="hljs-comment">#   limitations under the License.</span><br><br><span class="hljs-string">disabled_plugins</span> <span class="hljs-string">=</span> [<span class="hljs-string">&quot;cri&quot;</span>]<br><br><span class="hljs-comment">#root = &quot;/var/lib/containerd&quot;</span><br><span class="hljs-comment">#state = &quot;/run/containerd&quot;</span><br><span class="hljs-comment">#subreaper = true</span><br><span class="hljs-comment">#oom_score = 0</span><br><br><span class="hljs-comment">#[grpc]</span><br><span class="hljs-comment">#  address = &quot;/run/containerd/containerd.sock&quot;</span><br><span class="hljs-comment">#  uid = 0</span><br><span class="hljs-comment">#  gid = 0</span><br><br><span class="hljs-comment">#[debug]</span><br><span class="hljs-comment">#  address = &quot;/run/containerd/debug.sock&quot;</span><br><span class="hljs-comment">#  uid = 0</span><br><span class="hljs-comment">#  gid = 0</span><br><span class="hljs-comment">#  level = &quot;info&quot;</span><br></code></pre></td></tr></table></figure><p>然后将默认的配置文件写入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">containerd config default | sudo <span class="hljs-built_in">tee</span> /etc/containerd/config.toml<br></code></pre></td></tr></table></figure><p>为了在配置里头通过 <code>runc</code> 使用 <code>systemd</code> <code>cgroup</code> 驱动，进行如下设置</p><p><img src="/../assets/kubernetes/CZrubBOzuojoPUx4MA8czbb9nPd.png"></p><p>然后重启 <code>containerd</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl restart containerd<br></code></pre></td></tr></table></figure><h3 id="CRI-O"><a href="#CRI-O" class="headerlink" title="CRI-O"></a><code>CRI-O</code></h3><h3 id="Docker-Engine"><a href="#Docker-Engine" class="headerlink" title="Docker Engine"></a><code>Docker Engine</code></h3><h3 id="Mirantis-Container-Runtime"><a href="#Mirantis-Container-Runtime" class="headerlink" title="Mirantis Container Runtime"></a><code>Mirantis Container Runtime</code></h3><h1 id="kubernetes-部署运行"><a href="#kubernetes-部署运行" class="headerlink" title="kubernetes 部署运行"></a><code>kubernetes</code> 部署运行</h1><h2 id="Hello-Minikube"><a href="#Hello-Minikube" class="headerlink" title="Hello Minikube"></a><a href="https://kubernetes.io/docs/tutorials/hello-minikube/">Hello Minikube</a></h2><ol><li>事先准备<ol><li>建立 <code>minikube</code><ol><li>下载安装</li></ol></li></ol></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64<br>sudo install minikube-linux-amd64 /usr/local/bin/minikube<br></code></pre></td></tr></table></figure><ol><li>启动集群</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube start<br></code></pre></td></tr></table></figure><p>报错</p><blockquote><p>You appear to be using a proxy, but your NO_PROXY environment does not include the minikube IP (192.168.49.2)</p></blockquote><p><img src="/../assets/kubernetes/SSjYbN4P1o6Tfjxkt1rcu0QlnJc.png"></p><p><img src="/../assets/kubernetes/IVp3b49qQofAPjxhH3bcxiBAnca.png"></p><ol><li>与集群交互通信</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get po -A<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/Wvfvb3LIXopxGNx2flEcpirznOb.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube dashboard --url<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/KL3sbKt4goqBQyxxwwUcljNmnJe.png"></p><ol><li>创建一个部署</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl create deployment hello-node --image=registry.k8s.io/e2e-test-images/agnhost:2.39 -- /agnhost netexec --http-port=8080<br><br>kubectl get deployments<br></code></pre></td></tr></table></figure><h2 id="kind"><a href="#kind" class="headerlink" title="kind"></a><a href="https://kind.sigs.k8s.io/docs/user/quick-start/#installing-from-release-binaries">kind</a></h2><ol><li>下载二进制包</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[ $(<span class="hljs-built_in">uname</span> -m) = x86_64 ] &amp;&amp; curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64<br><br>sudo <span class="hljs-built_in">chmod</span> +x ./kind<br>sudo <span class="hljs-built_in">mv</span> ./kind /usr/local/bin/<br></code></pre></td></tr></table></figure><ol><li><code>kind</code> 创建集群</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kind create cluster<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/TOHcb6YcXoebCAxsl5ScamFtnBe.png"></p><ol><li>观测集群</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl cluster-info --context kind-kind<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/N77UbZtNhoknHqxexaXc8TCSnSg.png"></p><ol><li>关闭集群</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kind delete cluster<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/JEuDbTnoRoQypnxdPJycNLlVn2g.png"></p><h2 id="通过-kubeadm-创建一个集群"><a href="#通过-kubeadm-创建一个集群" class="headerlink" title="通过 kubeadm 创建一个集群"></a><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/">通过</a> <code>kubeadm</code> <a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/">创建一个集群</a></h2><ul><li>资源需求<ul><li>一台以上能跑 deb&#x2F;rpm 包的 Linux 系统</li><li>2G 以上的 RAM 空闲</li><li>在任意一个控制结点上至少有 2 个 CPU</li><li>网络通畅的环境下</li></ul></li></ul><p><strong>部署流程</strong></p><ol><li>准备 hosts</li></ol><p>在所有的网络主机上安装容器运行时 <a href="https://yxrt3ryg3jg.feishu.cn/docx/Xru9d9V7MoSk5kxsFJXcqtUjn2c#MphRdOe5woWWRkxItl8c2fqrnHg">Kubernetes</a></p><ol><li>准备需要的容器镜像（可选）</li><li>初始化控制节点(control-plane node)</li></ol><p>控制结点意味着其是作为控制组件的机器运行的，其包括 <code>etcd</code>（集群数据库）以及 <code>API Server</code>（用于 <code>kubectl</code> 与集群的通信）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubeadm init<br></code></pre></td></tr></table></figure><h1 id="Kind"><a href="#Kind" class="headerlink" title="Kind"></a>Kind</h1><h2 id="在集群中加载镜像"><a href="#在集群中加载镜像" class="headerlink" title="在集群中加载镜像"></a>在集群中加载镜像</h2><p>在一个已经运行的集群中加载一个 <code>docker-image</code>，<code>dockerfile</code> 如下</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:latest<br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> <span class="hljs-variable">$&#123;pwd&#125;</span>/code /code</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt update &amp;&amp; apt install -y python3-pip &amp;&amp; apt-get clean</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip install flask</span><br><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [ <span class="hljs-string">&quot;sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;python3 /code/app.py&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><code>code</code> 里头运行了一个简单的 <code>flask</code> 应用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello_world</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;p&gt;Hello World!&lt;/p&gt;&quot;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app.run(host=<span class="hljs-string">&quot;0.0.0.0&quot;</span>,port=<span class="hljs-number">8080</span>,debug=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>加载到集群中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kind load docker-image flask-image:latest<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/O2hIbVjzkoI2bfxS3QVcdavHnAf.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it kind-control-plane crictl images<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/TxjHbHJVsoPjNXxnIoLc8IuFnwc.png"></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="kubeadm-init"><a href="#kubeadm-init" class="headerlink" title="kubeadm init"></a><code>kubeadm init</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[WARNING Hostname]: hostname <span class="hljs-string">&quot;dydy-pc&quot;</span> could not be reached<br>[WARNING Hostname]: hostname <span class="hljs-string">&quot;dydy-pc&quot;</span>: lookup dydy-pc on 210.28.129.251:53: no such host<br></code></pre></td></tr></table></figure><p>修改 <code>/etc/hosts</code>，将 <code>localhost</code> 后面添加自己的电脑主机地址即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[ERROR CRI]: container runtime is not running: output: time=<span class="hljs-string">&quot;2023-09-19T09:03:23+08:00&quot;</span> level=fatal msg=<span class="hljs-string">&quot;validace connection: CRI v1 runtime API is not implemented for endpoint \&quot;unix:///var/run/containerd/containerd.sock\&quot;: rpc error: code = Unimplemented desc = unknown service runtime.v1.RuntimeService&quot;</span><br></code></pre></td></tr></table></figure><p><a href="https://yxrt3ryg3jg.feishu.cn/docx/Xru9d9V7MoSk5kxsFJXcqtUjn2c#part-RfVPd1aHPoNdExx7ppqcVT9Gn6f">Kubernetes 环境搭建</a></p><h2 id="kubeadm-config-images-pull"><a href="#kubeadm-config-images-pull" class="headerlink" title="kubeadm config images pull"></a><code>kubeadm config images pull</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">failed to pull image <span class="hljs-string">&quot;registry.k8s.io/kube-apiserver:v1.28.2&quot;</span>: output: E0919 09:32:01.239971   35982 remote_image.go:171] <span class="hljs-string">&quot;PullImage from image service failed&quot;</span> err=<span class="hljs-string">&quot;rpc error: code = Unavailable desc = connection error: desc = \&quot;transport: Error while dialing dial unix /var/run/containerd/containerd.sock: connect: permission denied\&quot;&quot;</span> image=<span class="hljs-string">&quot;registry.k8s.io/kube-apiserver:v1.28.2&quot;</span><br>time=<span class="hljs-string">&quot;2023-09-19T09:32:01+08:00&quot;</span> level=fatal msg=<span class="hljs-string">&quot;pulling image: rpc error: code = Unavailable desc = connection error: desc = \&quot;transport: Error while dialing dial unix /var/run/containerd/containerd.sock: connect: permission denied\&quot;&quot;</span><br>, error: <span class="hljs-built_in">exit</span> status 1<br></code></pre></td></tr></table></figure><p>生成默认配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubeadm config <span class="hljs-built_in">print</span> init-defaults &gt; init.default.yaml<br></code></pre></td></tr></table></figure><p>修改默认配置文件</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenWhisk 学习笔记</title>
    <link href="/2023/10/29/openwhisk/"/>
    <url>/2023/10/29/openwhisk/</url>
    
    <content type="html"><![CDATA[<h1 id="OpenWhisk概述"><a href="#OpenWhisk概述" class="headerlink" title="OpenWhisk概述"></a>OpenWhisk概述</h1><p>Openwhisk是属于Apache基金会的开源Faas计算平台，由IBM在2016年公布并贡献给开源社区。IBM Cloud本身也提供完全托管的OpenWhisk Faas服务IBM Cloud Function。从业务逻辑来看，OpenWhisk同AWS Lambda一样，为用户提供基于事件驱动的无状态的计算模型，并直接支持多种编程语言。</p><p>OpenWhisk特点：</p><ul><li>高性能，高扩展性的分布式FaaS计算平台</li><li>函数的代码及运行时全部在Docker容器中运行，利用Docker engine实现FaaS函数运行的管理、负载均衡、扩展.</li><li>OpenWhisk所有其他组件(如：API网关，控制器，触发器等)也全部运行在 Docker容器中。这使得OpenWhisk全栈可以很容易的部署在任意IaaS&#x2F;PaaS平台上。</li><li>相比其他FaaS实现(比如OpenFaaS)，OpenWhisk更像是一套完整的Serverless 解决方案，除了容器的调用和函数的管理，OpenWhisk 还包括了用户身份验证&#x2F;鉴权、函数异步触发等功能。</li></ul><p>目前支持的语言: <code>Nodejs</code>, <code>Python</code>, <code>Java</code>, <code>php</code>, <code>Ruby</code>, <code>Go</code>, <code>Rust</code>, <code>dotnet</code>, <code>Ballerina</code>, <code>blackBoxes</code>。</p><h1 id="OpenWhisk环境搭建"><a href="#OpenWhisk环境搭建" class="headerlink" title="OpenWhisk环境搭建"></a>OpenWhisk环境搭建</h1><h2 id="安装Java"><a href="#安装Java" class="headerlink" title="安装Java"></a>安装Java</h2><p>deepin上安装Java的方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install default-jre<br>sudo apt-get install default-jdk<br>安装nodejs<br><span class="hljs-comment">#下载Node.js安装包</span><br>wget https://nodejs.org/dist/v10.15.3/node-v10.15.3-linux-x64.tar.xz<br><span class="hljs-comment">#解压文件</span><br>tar xvf node-v10.15.3-linux-x64.tar.xz<br><span class="hljs-comment">#移动到相应目录下</span><br><span class="hljs-built_in">mv</span> ./node-v10.15.3-linux-x64 ./node<br><span class="hljs-built_in">mv</span> ./node /opt/node<br><span class="hljs-comment">#添加环境变量</span><br><span class="hljs-built_in">cd</span> <br>vim .bash_profile<br><span class="hljs-comment">#node</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/opt/node/bin<br></code></pre></td></tr></table></figure><h2 id="编译openwhisk"><a href="#编译openwhisk" class="headerlink" title="编译openwhisk"></a>编译openwhisk</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># git clone下来</span><br>git <span class="hljs-built_in">clone</span> https://github.com/apache/incubator-openwhisk.git openwhisk<br><span class="hljs-comment"># 切换到openwhisk目录，运行下面命令</span><br>$ ./gradlew :core:standalone:build<br></code></pre></td></tr></table></figure><p><img src="/../assets/openwhisk/o1.PNG"><br><img src="/../assets/openwhisk/o2.PNG"></p><h2 id="配置OpenWhisk-Cli工具"><a href="#配置OpenWhisk-Cli工具" class="headerlink" title="配置OpenWhisk Cli工具"></a>配置OpenWhisk Cli工具</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">- github下载网址：https://link.zhihu.com/?target=https%3A//github.com/apache/openwhisk-cli 下载二进制文件<br><span class="hljs-comment"># 上传到服务器解压, 解压</span><br><span class="hljs-comment"># 设置API HOST</span><br>wsk property <span class="hljs-built_in">set</span> --apihost http://172.17.0.1:3233<br><span class="hljs-comment"># 设置auth</span><br>wsk property <span class="hljs-built_in">set</span> --auth 789c46b1-71f6-4ed5-8c54-816aa4f8c502<br><span class="hljs-comment"># 可以通过以下命令获取当前的auth</span><br>wsk property get --auth<br></code></pre></td></tr></table></figure><p><img src="/../assets/openwhisk/o3.png"></p><h2 id="配置Docker"><a href="#配置Docker" class="headerlink" title="配置Docker"></a>配置Docker</h2><p><a href="https://cloud.tencent.com/developer/article/1753250">https://cloud.tencent.com/developer/article/1753250</a></p><ol><li>卸载旧版本残留</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get remove docker.io docker-engine<br></code></pre></td></tr></table></figure><ol start="2"><li>下载并安装密钥</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/debian/gpg | sudo apt-key add -<br></code></pre></td></tr></table></figure><ol start="3"><li>检查是否安装成功</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-key fingerprint 0EBFCD88<br></code></pre></td></tr></table></figure><p><img src="/../assets/openwhisk/o4.png"></p><ol start="4"><li>在source.list中添加docker-ce的软件源</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo deepin-editor /etc/apt/sources.list.d/docker.list <span class="hljs-comment"># 使用 deepin 默认的编辑器新建并打开 docker.list 文件</span><br><span class="hljs-comment"># 写入一条内容如下：</span><br>deb [<span class="hljs-built_in">arch</span>=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/debian buster stable <span class="hljs-comment"># 这里 buster 是 debain 版本的代号，deepin20 是debain10 代号为 buster，编辑完成后保存</span><br>注意： 使用 <span class="hljs-built_in">cat</span> /etc/debian_version 查看自己的 debain 版本。<br></code></pre></td></tr></table></figure><ol start="5"><li>更新仓库</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br></code></pre></td></tr></table></figure><ol start="6"><li>安装docker</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><ol start="7"><li>验证</li></ol><p><img src="/../assets/openwhisk/o5.png"><br><img src="/../assets/openwhisk/o6.png"></p><ol><li>管理启动项</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install chkconfig <br><span class="hljs-comment"># 列出所有启动项</span><br>sudo chkconfig<br><span class="hljs-comment"># chkconfig --help 查看帮助命令</span><br><br>sudo chkconfig --del docker<br></code></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>在openwhisk的bin目录下会有相应的可执行文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar openwhisk-standalone.jar<br></code></pre></td></tr></table></figure><p>如果docker需要管理员权限就加个sudo</p><p><img src="/../assets/openwhisk/o7.png"></p><p>服务起来后设置提示的命令:设置apihost和auth</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsk property <span class="hljs-built_in">set</span> --apihost <span class="hljs-string">&#x27;http://172.17.0.1:3233&#x27;</span> --auth <span class="hljs-string">&#x27;23bc46b1-71f6-4ed5-8c54-816aa4f8c502:123zO3xZCLrMN6v2BKK1dXYFpXlPkccOFqm12CdAsMgRU4VrNZ9lyGVCGuMDGIwP&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="/../assets/openwhisk/o8.png"><br><img src="/../assets/openwhisk/o9.png"></p><h1 id="OpenWhisk包下载"><a href="#OpenWhisk包下载" class="headerlink" title="OpenWhisk包下载"></a>OpenWhisk包下载</h1><h2 id="Catalog包"><a href="#Catalog包" class="headerlink" title="Catalog包"></a>Catalog包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/apache/openwhisk-catalog<br><span class="hljs-built_in">cd</span> openwhisk-catalog<br><span class="hljs-comment">#将一些变量添加进来</span><br>vim ~/.bashrc<br><br><span class="hljs-comment">#openwhisk</span><br>OPENWHISK_HOME=~/Serverless/openwhisk<br>WSK=<span class="hljs-variable">$OPENWHISK_HOME</span>/bin<br>CLI_PATH=<span class="hljs-variable">$OPENWHISK_HOME</span>/bin/wsk<br>API_HOST=http://172.17.0.1:3233<br>AUTH=789c46b1-71f6-4ed5-8c54-816aa4f8c502:abczO3xZCLrMN6v2BKK1dXYFpXlPkccOFqm12CdAsMgRU4VrNZ9lyGVCGuMDGIwP<br><span class="hljs-built_in">export</span> OPENWHISK_HOME CLI_PATH API_HOST API_KEY<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$WSK</span><br><br><br><span class="hljs-comment">#在本地standalone运行时下载包</span><br>./packages/installCatalogUsingWskdeploy.sh <span class="hljs-variable">$AUTH</span> <span class="hljs-variable">$API_HOST</span> <span class="hljs-variable">$CLI_PATH</span><br><span class="hljs-comment">#然后验证</span><br>wsk package list /whisk.system<br></code></pre></td></tr></table></figure><p><img src="/../assets/openwhisk/o10.png"></p><h1 id="OpenWhisk-couchDB数据库配置"><a href="#OpenWhisk-couchDB数据库配置" class="headerlink" title="OpenWhisk couchDB数据库配置"></a>OpenWhisk couchDB数据库配置</h1><ol><li>依次执行以下3条命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update &amp;&amp; sudo apt install -y curl apt-transport-https gnupg<br>curl https://couchdb.apache.org/repo/keys.asc | gpg --dearmor | sudo <span class="hljs-built_in">tee</span> /usr/share/keyrings/couchdb-archive-keyring.gpg &gt;/dev/null 2&gt;&amp;1source /etc/os-release<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb [signed-by=/usr/share/keyrings/couchdb-archive-keyring.gpg] https://apache.jfrog.io/artifactory/couchdb-deb/ <span class="hljs-variable">$&#123;VERSION_CODENAME&#125;</span> main&quot;</span> \| sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/couchdb.list &gt;/dev/null<br></code></pre></td></tr></table></figure><ol start="2"><li>执行后你可以在<code>/etc/apt/source.list.d</code>里头看到<code>couchdb.list</code>文件，用<code>vim</code>打开，将里头的<code>apricot</code>改为<code>buster</code>，因为原来那个在网站上的资源没有了T_T</li><li>之后更新源后下载couchdb</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br>sudo apt install couchdb<br></code></pre></td></tr></table></figure><ol start="4"><li>新建一个文件夹后在里头导出一些环境变量</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> logconf &amp;&amp; <span class="hljs-built_in">cd</span> logconf<br>vim wsk_env.sh<br><span class="hljs-built_in">export</span> OW_DB=CouchDB<br><span class="hljs-built_in">export</span> OW_DB_USERNAME=openwhisk<br><span class="hljs-built_in">export</span> OW_DB_PASSWORD=openwhisk<br><span class="hljs-built_in">export</span> OW_DB_PROTOCOL=http<br><span class="hljs-built_in">export</span> OW_DB_HOST=127.0.0.1<br><span class="hljs-built_in">export</span> OW_DB_PORT=4444<br><span class="hljs-built_in">export</span> OPENWHISK_TMP_DIR=~/Serverles/logconf<br></code></pre></td></tr></table></figure><ol start="5"><li>之后进行ansible安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> openwsk_env.sh<br><span class="hljs-built_in">cd</span> ansible<br>ansible-playbook -i environments/local setup.yml<br></code></pre></td></tr></table></figure><p><img src="/../assets/openwhisk/o11.png"></p><p><img src="/../assets/openwhisk/o12.png"></p><h1 id="OpenWhisk内部流程"><a href="#OpenWhisk内部流程" class="headerlink" title="OpenWhisk内部流程"></a>OpenWhisk内部流程</h1><p><img src="/../assets/openwhisk/o13.png"></p><ol><li>面向用户的REST API(Nginx)：OpenWhisk通过Nginx 接收函数触发和函数的CRUD请求。</li><li>控制器(Controller): 真正处理请求的地方。</li><li>CouchDB(身份验证和鉴权):控制器首先需要验证用户的身份和权限。用户的身份信息保存在CouchDB的用户身份数据库中。验证无误后，控制器进行下一步处理。</li><li>CouchDB: 确认用户的身份后，控制器需要从 CouchDB中读取将要被触发的action。action对应的数据存储在CouchDB的whisk 数据库，主要包含要被执行的代码、默认参数、被执行代码的权限等。</li><li>Consul和负载均衡:控制器已经有了触发函数所需要的全部信息，在将数据发送给触发器(Invoker)之前，控制器需要和Consul确认，从Consul 获取处于空闲状态的触发器的地址。Consul 是一个开源的服务注册&#x2F;发现系统，在 OpenWhisk中Consul负责记录跟踪所有触发器的状态信息。当控制器向Consul发出请求，Consul从后台随机选取一个空闲的触发器信息，并返回。</li><li>触发请求送进Kafka: Kafka 充当了Controller和Invoker之间的缓存，当后端 Invoker 负载过大，没有及时处理Kafka数据流中的请求时，Controller 依然可以将请求送入Kafka，无需阻塞当前线程。同时所有送进Kafka 的请求消息都会被以log的形式的形式保存在文件系统中，即使系统瘫痪，已经由 Controller发出的请求也不会丢失。</li><li>触发器运行用户代码: 触发器从对应的 Kafka topic 中接收控制器传来的请求，并执行响应代码。OpenWhisk 的触发器是构建在 Docker 之上的，每一个函数触发都运行在一个独立的 Docker 容器之内.</li><li>CouchDB 保存运行结果: 触发器执行结果最终会被保存在 CouchDB 中的 whisk 数据库里</li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/weixin_51971301/article/details/121436849">openwhisk配置流程</a><br><a href="https://mlog.club/article/5772204">bbs-go-site</a><br><a href="https://docs.couchdb.org/en/latest/install/unix.html#installation-using-the-apache-couchdb-convenience-binary-packages">1.1. Installation on Unix-like systems ‒ Apache CouchDB® 3.2 Documentation</a></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenWhisk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 笔记</title>
    <link href="/2023/10/28/docker/"/>
    <url>/2023/10/28/docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p>卸载旧版本残留</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get remove docker.io docker-engine<br></code></pre></td></tr></table></figure><ol><li>下载并安装密钥</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/debian/gpg | sudo apt-key add -<br></code></pre></td></tr></table></figure><ol start="2"><li>检查是否安装成功</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-key fingerprint 0EBFCD88<br></code></pre></td></tr></table></figure><p><img src="/../assets/docker/docker1.PNG"></p><ol start="3"><li>在source.list中添加docker-ce的软件源</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo deepin-editor /etc/apt/sources.list.d/docker.list <span class="hljs-comment"># 使用 deepin 默认的编辑器新建并打开 docker.list 文件</span><br><span class="hljs-comment"># 写入一条内容如下：</span><br>deb [<span class="hljs-built_in">arch</span>=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/debian buster stable <span class="hljs-comment"># 这里 buster 是 debain 版本的代号，deepin20 是debain10 代号为 buster，编辑完成后保存</span><br></code></pre></td></tr></table></figure><p>注意： 使用 cat &#x2F;etc&#x2F;debian_version 查看自己的 debain 版本。</p><ol start="4"><li>更新仓库</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br></code></pre></td></tr></table></figure><ol start="5"><li>安装docker</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><ol start="6"><li><p>验证<br><img src="/../assets/docker/docker2.PNG"></p></li><li><p>管理启动项</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install chkconfig <br><span class="hljs-comment"># 列出所有启动项</span><br>sudo chkconfig<br><span class="hljs-comment"># chkconfig --help 查看帮助命令</span><br><br>sudo chkconfig --del docker<br></code></pre></td></tr></table></figure><ol start="8"><li>Rootless 配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo usermod -aG docker <span class="hljs-variable">$USER</span><br>reboot<br></code></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="拷贝文件夹"><a href="#拷贝文件夹" class="headerlink" title="拷贝文件夹"></a>拷贝文件夹</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> &lt;container&gt;:&lt;container-dir&gt; &lt;local-dir&gt;<br></code></pre></td></tr></table></figure><h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><h2 id="环境安装-1"><a href="#环境安装-1" class="headerlink" title="环境安装"></a>环境安装</h2><ol><li>下载二进制包</li></ol><p><a href="https://github.com/docker/compose/releases">https://github.com/docker/compose/releases</a></p><ol start="2"><li>添加权限并移动到&#x2F;usr&#x2F;local&#x2F;bin下</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chmod</span> 755 docker-compose-linux-x86_64<br>sudo <span class="hljs-built_in">mv</span> docker-compose-linux-x86_64 /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><ol start="3"><li>验证</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose<br></code></pre></td></tr></table></figure><p><img src="/../assets/docker/docker3.png"></p><h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><h3 id="1-定义应用依赖"><a href="#1-定义应用依赖" class="headerlink" title="1. 定义应用依赖"></a>1. 定义应用依赖</h3><p>使用一个简单的程序</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">import</span> redis<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br>app = Flask(__name__)<br>cache = redis.Redis(host=<span class="hljs-string">&#x27;redis&#x27;</span>, port=<span class="hljs-number">6379</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_hit_count</span>():<br>    retries = <span class="hljs-number">5</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> cache.incr(<span class="hljs-string">&#x27;hits&#x27;</span>)<br>        <span class="hljs-keyword">except</span> redis.exceptions.ConnectionError <span class="hljs-keyword">as</span> exc:<br>            <span class="hljs-keyword">if</span> retries == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">raise</span> exc<br>            retries -= <span class="hljs-number">1</span><br>            time.sleep(<span class="hljs-number">0.5</span>)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():<br>    count = get_hit_count()<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello World! I have been seen &#123;&#125; times.\n&#x27;</span>.<span class="hljs-built_in">format</span>(count)<br></code></pre></td></tr></table></figure><p>并提供其软件包<code>requirements.txt</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">flask<br>redis<br></code></pre></td></tr></table></figure><h3 id="2-定义一个Dockerfile"><a href="#2-定义一个Dockerfile" class="headerlink" title="2. 定义一个Dockerfile"></a>2. 定义一个Dockerfile</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># syntax=docker/dockerfile:1</span><br><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.7</span>-alpine<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /code</span><br><span class="hljs-keyword">ENV</span> FLASK_APP=app.py<br><span class="hljs-keyword">ENV</span> FLASK_RUN_HOST=<span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apk add --no-cache gcc musl-dev linux-headers</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> requirements.txt requirements.txt</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">5000</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;flask&quot;</span>, <span class="hljs-string">&quot;run&quot;</span>]</span><br></code></pre></td></tr></table></figure><h3 id="3-定义一个compose文件"><a href="#3-定义一个compose文件" class="headerlink" title="3. 定义一个compose文件"></a>3. 定义一个compose文件</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">services:<br>  web:<br>    build: .<br>    ports:<br>      - <span class="hljs-string">&quot;8000:5000&quot;</span><br>  redis:<br>    image: <span class="hljs-string">&quot;redis:alpine&quot;</span><br></code></pre></td></tr></table></figure><h3 id="4-构建运行"><a href="#4-构建运行" class="headerlink" title="4. 构建运行"></a>4. 构建运行</h3><p>运行<code>docker compose up</code></p><p><img src="/../assets/docker/docker4.png"><br><img src="/../assets/docker/docker5.png"><br>停止运行<code>docker compose down</code></p><h3 id="5-compose文件添加挂载"><a href="#5-compose文件添加挂载" class="headerlink" title="5. compose文件添加挂载"></a>5. compose文件添加挂载</h3><p>重新编辑一下compose文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">services:<br>  web:<br>    build: .<br>    ports:<br>      - <span class="hljs-string">&quot;8000:5000&quot;</span><br>    volumes:<br>      - .:/code<br>    environment:<br>      FLASK_DEBUG: <span class="hljs-string">&quot;true&quot;</span><br>  redis:<br>    image: <span class="hljs-string">&quot;redis:alpine&quot;</span><br></code></pre></td></tr></table></figure><h3 id="6-重新构建"><a href="#6-重新构建" class="headerlink" title="6. 重新构建"></a>6. 重新构建</h3><p><img src="/../assets/docker/docker6.png"></p><h3 id="7-应用更新"><a href="#7-应用更新" class="headerlink" title="7. 应用更新"></a>7. 应用更新</h3><p>由于在上面的步骤中，我们将应用程序的代码与容器进行挂载，因此，当我们现在对源代码进行修改时，容器里头的代码也会跟着修改</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello from Docker! I have been seen &#123;&#125; times.\n&#x27;</span>.<span class="hljs-built_in">format</span>(count)<br></code></pre></td></tr></table></figure><p><img src="/../assets/docker/docker7.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
