<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Serverless 函数编排</title>
    <link href="/2023/11/01/serverless_orchestration/"/>
    <url>/2023/11/01/serverless_orchestration/</url>
    
    <content type="html"><![CDATA[<h1 id="Serverless-函数编排"><a href="#Serverless-函数编排" class="headerlink" title="Serverless 函数编排"></a>Serverless 函数编排</h1><h1 id="系统目标"><a href="#系统目标" class="headerlink" title="系统目标"></a>系统目标</h1><ul><li>构建一套基于事件驱动的有限状态机模型的函数编排系统，可以编排不同云平台上的 Serverless 函数<ul><li>异构平台的标准化<ul><li>支持不同云平台函数的运行时</li><li>支持不同云平台的事件处理</li></ul></li><li>高效执行<ul><li>基于事件驱动的有限状态机模型</li><li>函数并行度优化</li></ul></li><li>简单部署<ul><li>前端：函数式编程</li><li>中端：Workflow 静态图</li><li>后端：运行时组件</li></ul></li></ul></li></ul><h1 id="模型构建"><a href="#模型构建" class="headerlink" title="模型构建"></a>模型构建</h1><h2 id="有限状态机模型"><a href="#有限状态机模型" class="headerlink" title="有限状态机模型"></a>有限状态机模型</h2><p>使用有限状态机管理触发器</p><h2 id="事件抽象"><a href="#事件抽象" class="headerlink" title="事件抽象"></a>事件抽象</h2><p>事件作为外部输入关系触发器</p><h2 id="函数流"><a href="#函数流" class="headerlink" title="函数流"></a>函数流</h2><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><h2 id="Triggerflow-Trigger-based-orchestration-of-serverless-workflows"><a href="#Triggerflow-Trigger-based-orchestration-of-serverless-workflows" class="headerlink" title="Triggerflow: Trigger-based orchestration of serverless workflows"></a><a href="https://www.sciencedirect.com/science/article/pii/S0167739X21001989">Triggerflow: Trigger-based orchestration of serverless workflows</a></h2><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>现有的云编排系统要么专注于短期运行的工作流程，要么为同步大规模并行作业带来相当大的开销。没有能够对自定义工作流进行可扩展拦截以及优化的开放系统</p><ul><li>短期运行：IBM Composer、Amazon Step Functions Express Workflows</li><li>大开销：Azure Durable Functions、Amazon Step Functions</li></ul><h3 id="工作难点"><a href="#工作难点" class="headerlink" title="工作难点"></a>工作难点</h3><ul><li><p>通过 CEP 规则执行业务流程</p><ul><li>CEP：Complex Event Processing</li></ul></li><li><p>使用触发器做服务工作流编排是可能的但是往往不理想</p><ul><li>有必要为每个步骤创建不同的队列或目录</li><li>触发器不能够一直等到前面多个函数的执行结束</li><li>触发器不适用于错误处理</li></ul></li></ul><h3 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h3><ul><li><p>利用基于内容的发布&#x2F;订阅系统中的复合订阅来提供分散的基于事件的工作流程管理 <a href="https://link.springer.com/chapter/10.1007/11587552_13">link.springer.com</a></p></li><li><p><a href="https://serverlessworkflow.io/">serverlessworkflow.io</a> 该工作提出将工作流声明为 YAML 文件，其中包含要使用的 CloudEvents 概述、无服务器函数的事件驱动调用以及工作流数据管理和控制流逻辑的状态转换。</p><ul><li>定义了一个可以被不同系统解释的抽象定义，从而保证可移植性避免供应商锁定</li></ul></li><li><p>当下的 Serverless 编排系统大多数依赖于集中式的服务器资源（虚拟机）或者是专有资源</p><ul><li>坏处<ul><li>不能将资源占有量降为 0</li><li>工作流执行时编排组件持续活跃，工作流执行时间长时造成资源浪费</li></ul></li></ul></li><li><p>IBM Composer 生成一个状态机代表着即将要被执行的 IBM Cloud Functions</p><ul><li>能够表示顺序、条件分支、循环、并行以及任务映射</li><li><code>fork/join</code> 同步阻塞了外部用户提供的 <code>Redis</code> 服务，限制了其对短期运行任务的适用性</li></ul></li><li><p>Amazon Step Functions and Amazon Step Functions Express Workflows 使用 JSON 模型化任务转移、选择、等待、并行、映射，ASF 是一个支持 Workflow 错误容忍服务，ASFE 时用户支撑短时运行的工作负载</p></li><li><p>微软的 Azure Durable Functions（ADF）提出了使用代码生成 Workflows 的方式，使用 <code>async/await</code> 结构，使用事件源重启被挂起的工作流</p><ul><li>不支持映射工作</li><li>只包含了 <code>Task.whenAll</code> 抽象来实现 <code>fork/join</code></li></ul></li><li><p>谷歌云提供了 Google Cloud Workflows 服务。它的工作流包括了一系列的基于逻辑的步骤，逻辑类似于条件或者循环。可以通过对每一个步骤发出一个 HTTP Request 的方式来触发 Google Cloud Function</p><ul><li>不适合用来做广播的并行任务</li></ul></li></ul><h3 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h3><ul><li><p>ECA 模型：Event-Condition-Action, <code>Event Sources</code> and <code>Programmable Conditions</code> and <code>Actions</code></p><ul><li>包含触发器和规则：适合定义表示工作流的有限状态机的状态转移</li></ul></li><li><p>触发器服务</p><ul><li>Workflow: 由 6 元组组成的一个有限状态机<ul><li>输入事件的集合</li><li>上下文变量</li><li>将 Actions 映射到 ECA 模型</li><li>初始状态</li><li>终止状态</li><li>状态转移方程，通过 ECA 触发器转移</li></ul></li><li>Trigger: 可以看作是状态转移方程，由四元组构成<ul><li>事件：驱动云应用的院原子信息。使用 subject 字段匹配事件对应的触发器，使用 type 字段描述事件的类型</li><li>上下文：一个 key-value 的数据结构，包含了触发器运行周期的状态</li><li>条件：由用户定义的决定事件是否匹配行为</li><li>行为：用于异步地触发一个 Serverless 函数</li></ul></li></ul><blockquote><p>触发器的生命周期可以表示如下：</p><ol><li>一个事件由某些事件源产生</li><li>事件被系统消费，激活对应的触发器</li><li>事件由 Condition 函数处理，若结果是正确的，就交由 Action 函数处理</li><li>Action 函数被激活了，就称作该触发器被 fired</li><li>当一个触发器被 fired 的时候，他就可以被 disabled 或者由系统 maintain<ul><li>Mapping Workflows to Triggers：一个工作流可以通过一系列触发器进行映射</li><li>任意工作流抽象都可以通过有限状态机表示，可以被转化为各种各样的触发器，并且通过 TriggerFlow 表示</li><li>Substitution Principle：工作流本身通过初始化和终止遵守操作。工作流可以嵌套</li><li>Dynamic Trigger Interception：</li></ul></li></ol></blockquote></li><li><p>错误容忍：</p><ul><li>事件总线保证事件的至少一次传递<ul><li>事件可以重复无序</li></ul></li><li>通过 CloudEvent 标准为每个事件赋予一个 ID<ul><li>在事件处理阶段，同样 ID 的事件就会丢弃</li></ul></li><li>通过辨别两种事件组合类型来处理无序消息<ul><li>聚合：如计数器。由于消息顺序不会改变最终结果，故不用考虑</li><li>序列：仅仅处理激活序列开头的触发器的事件，其他事件将被延迟，直到启用他们激活的触发器</li></ul></li></ul></li></ul><h2 id="Comparison-of-FaaS-Orchestration-Systems"><a href="#Comparison-of-FaaS-Orchestration-Systems" class="headerlink" title="Comparison of FaaS Orchestration Systems"></a><a href="https://ieeexplore.ieee.org/abstract/document/8605772">Comparison of FaaS Orchestration Systems</a></h2><h3 id="解决问题-1"><a href="#解决问题-1" class="headerlink" title="解决问题"></a>解决问题</h3><p>本文章比较了四种函数编排平台 AWS Lambda, IBM Cloud Functions, Google Cloud Functions,Azure Functions</p><h3 id="相关工作-1"><a href="#相关工作-1" class="headerlink" title="相关工作"></a>相关工作</h3><ul><li><p>IBM Serverless 的三大难题</p><ul><li>函数需要在一个沙箱中进行</li><li>函数组合应该遵循同步调用的替换原则（即组合也应该是一个函数）</li><li>调用不应该重复计费</li></ul></li><li><p>编排函数不需要外部的运行时支持</p><ul><li>两种解决模式<ul><li>使用函数进行编排<ul><li>函数的编排是在一个 Serverless 函数中进行的</li><li>带来双重付费的问题</li></ul></li><li>使用外部的客户端进行编排<ul><li>能够解决双重付费问题</li><li>不能视为函数，违反替换原则</li></ul></li></ul></li></ul></li></ul><h3 id="评估模型"><a href="#评估模型" class="headerlink" title="评估模型"></a>评估模型</h3><ul><li>ST-safeness：符合三难困境的编排服务被称为 STsafe。</li><li>Programming model：编程简单性和编码抽象集，是否提供反射 API 来观察函数组合的当前状态。</li><li>Parallel execution support：并行执行支持</li><li>State management：数据如何从一个函数转移到下一个函数</li><li>Architecture：编排器是客户端调度程序或者是本身就是一个函数，用于事件的响应</li><li>Overhead：鉴于编排服务对函数调度程序的依赖，应针对代表性函数组合（例如链和并行模式）来衡量编排开销的重要性</li><li>Billing model</li></ul><h3 id="评估结果"><a href="#评估结果" class="headerlink" title="评估结果"></a>评估结果</h3><table><thead><tr><th></th><th>ST-safeness</th><th>Programming model</th><th>Parallel execution support</th><th>State management</th><th>Architecture</th><th>Overhead</th></tr></thead><tbody><tr><td>Amazon Step Functions (ASF)</td><td>不满足，因为函数编排不是函数</td><td>- 支持顺序和分支，函数重试以及并行。- 只能静态图- 提供了反射 API 查询状态以及取消执行- 通过 CloudWatch 监控</td><td>支持</td><td>32KB 的限制</td><td>外部编排器</td><td></td></tr><tr><td>IBM Composer</td><td>满足，也是第一个满足的</td><td>- 提供了完整的编排库- 不提供并行的 DSL- 但是可以将函数作为前端接口暴露- 不支持反射 API，只能通过日志</td><td>不支持</td><td>5MB 的状态转移限制</td><td>集成在反应式核心中</td><td>提供了包，支持用户上传包</td></tr><tr><td>Azure Durable Functions (ADF)</td><td>满足</td><td>- 通过 C#代码创建函数流- 提供了反射 API，不仅能获取当前的状态，也能触发事件到一个挂起的函数</td><td>支持</td><td>不限制</td><td>外部编排器</td><td>提供了非常简单的包</td></tr></tbody></table><h2 id="FaaSFlow-enable-efficient-workflow-execution-for-function-as-a-service"><a href="#FaaSFlow-enable-efficient-workflow-execution-for-function-as-a-service" class="headerlink" title="FaaSFlow: enable efficient workflow execution for function-as-a-service"></a><a href="https://dl.acm.org/doi/10.1145/3503222.3507717">FaaSFlow: enable efficient workflow execution for function-as-a-service</a></h2><h3 id="解决问题-2"><a href="#解决问题-2" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>传统的 master-worker 架构性能太差<ul><li>master 的调度模式，通过该模式，功能在 master 节点中触发并分配给工作节点来执行。</li><li>worker 之间的数据移动也会降低吞吐量。</li></ul></li></ul><blockquote><p>These serverless workflow systems usually provide a centralized workflow engine on the master node to manage the workflow execution state and assign function tasks to the worker nodes. We refer to this scheduling pattern as master-side workflow schedule pattern (denoted by MasterSP), as the central workflow engine in the master node determines whether a function task is triggered to run or not<br><img src="/../assets/serverless_workflow/ZlhlbGgQ7oYaSrx0LlycRwvinbg.png"><br>这些无服务器工作流系统通常在主节点上提供集中式工作流引擎来管理工作流执行状态并将功能任务分配给工作节点。我们将这种调度模式称为主端工作流调度模式（记为 MasterSP），由主节点中的中央工作流引擎决定是否触发功能任务运行</p></blockquote><ul><li>带来的问题<ul><li>中央工作流引擎负责动态管理和调度所有功能。函数执行状态频繁地从主节点转移到工作节点，带来大量的调度开销。由于函数很短，这种传输会频繁发生。</li><li>引擎“随机”将触发的函数分发到工作节点以实现负载均衡，云厂商对函数的输入输出数据大小进行配额，以避免严重消耗网络带宽。在生产无服务器平台中，用户通常依赖额外的数据库存储服务来进行临时数据存储和交付，从而承受巨大的数据移动开销</li></ul></li></ul><h3 id="工作难点-1"><a href="#工作难点-1" class="headerlink" title="工作难点"></a>工作难点</h3><ul><li><p>WorkerSP: 大规模工作流划分为控制平面以及数据平面</p><ul><li>worker 函数可以执行自动缩放并重用热容器，这导致控制平面中的每个功能节点在数据中可能具有多个不同的数据平面</li><li>在无服务器工作流的实际控制平面（用户预定义）和数据平面（数据依赖）不一定相同的情况下，将大规模工作流划分为两个不同平面的多个工作人员时具有挑战性</li><li>考虑到集群中资源动态变化的前提，还需要一种基于实时资源可用性来划分和调度工作流的机制</li></ul></li><li><p>FaaStore: 利用主内存在函数之间交换数据</p><ul><li>没有理论指导</li></ul></li></ul><h3 id="相关工作-2"><a href="#相关工作-2" class="headerlink" title="相关工作"></a>相关工作</h3><ul><li>函数冷启动问题</li><li>Serverless Workflow 优化</li></ul><h3 id="模型定义-1"><a href="#模型定义-1" class="headerlink" title="模型定义"></a>模型定义</h3><ul><li>FaaSFlow<ul><li>工作流图调度程序在 <code>Master</code> 节点上运行。图调度器解析用户上传的工作流，根据每个工作节点上的可用资源和相邻功能之间传输的数据量将工作流划分为子图。</li><li>在每个 <code>Worker</code> 节点上，<ul><li>FaaSFlow 运行一个 <code>pre-worker</code> 工作流引擎来管理函数状态并触发本地函数任务，</li><li>一个集成的 FaaStore 在运行时动态分配容器中超额配置的内存</li></ul></li><li>FaaStore<ul><li>使用适当的数据存储（容器中分配良好的主内存或远程存储）来支持基于功能的位置和依赖性的通信。</li></ul></li></ul></li></ul><h4 id="Graph-Scheduler"><a href="#Graph-Scheduler" class="headerlink" title="Graph Scheduler"></a>Graph Scheduler</h4><h4 id="Per-Worker-Workflow-Engine"><a href="#Per-Worker-Workflow-Engine" class="headerlink" title="Per-Worker Workflow Engine"></a>Per-Worker Workflow Engine</h4><h4 id="Memory-Reclamation-in-FaaStore"><a href="#Memory-Reclamation-in-FaaStore" class="headerlink" title="Memory Reclamation in FaaStore"></a>Memory Reclamation in FaaStore</h4><h3 id="开源代码"><a href="#开源代码" class="headerlink" title="开源代码"></a>开源代码</h3><p><a href="https://github.com/lzjzx1122/FaaSFlow">https://github.com/lzjzx1122/FaaSFlow</a></p><h2 id="Distributed-Transactions-on-Serverless-Stateful-Functions"><a href="#Distributed-Transactions-on-Serverless-Stateful-Functions" class="headerlink" title="Distributed Transactions on Serverless Stateful Functions"></a><a href="https://dl.acm.org/doi/abs/10.1145/3465480.3466920">Distributed Transactions on Serverless Stateful Functions</a></h2><h3 id="解决问题-3"><a href="#解决问题-3" class="headerlink" title="解决问题"></a>解决问题</h3><p>当前的 Serverless 计算缺乏正确的状态管理支持，也缺乏函数到函数之间的调用能力</p><ul><li>在一个有状态的数据流引擎实现事务处理</li><li>提出一个在有状态的 Serverless 函数之间进行事务处理的编程模型</li><li>实现了两个在云应用使用的主要方法来实现事务处理保证：两阶段提交协议以及 Saga Workflow</li><li>在云基础设施上使用 YCSB 基准的扩展版本来评估两种事务方案</li></ul><h3 id="相关工作-3"><a href="#相关工作-3" class="headerlink" title="相关工作"></a>相关工作</h3><ul><li><p>Beldi 在有状态函数之间提供了拥有错误容忍的 ACID 事务处理</p><ul><li>方法：将函数的操作记录到 Serverless 云数据库</li></ul></li><li><p>Cloudburst 为形成 DAG 的功能工作流提供了因果一致性</p><ul><li>方法：通过 Anna，一个具有冲突解决策略的键值存储</li></ul></li></ul><h2 id="Durable-functions-semantics-for-stateful-serverless"><a href="#Durable-functions-semantics-for-stateful-serverless" class="headerlink" title="Durable functions: semantics for stateful serverless"></a><a href="https://dl.acm.org/doi/abs/10.1145/3485510">Durable functions: semantics for stateful serverless</a></h2><h3 id="解决问题-4"><a href="#解决问题-4" class="headerlink" title="解决问题"></a>解决问题</h3><p>FaaS 编程模式的无状态问题</p><h3 id="工作难点-2"><a href="#工作难点-2" class="headerlink" title="工作难点"></a>工作难点</h3><ul><li>持久化执行进度。许多应用需要大型或者长时间运行的函数的可靠执行，因此执行进度必须可持久化。由于大部分的语言运行时都不支持在一个正在运行的程序中检查状态，因此很难有一个简单自动且稳健的方式去持久化函数的执行进度</li><li>持久化应用状态。所有的可持久化的状态都必须通过外部的数据库进行存储，并且在使用时还必须显式地读写。由于 FaaS 的执行能力弱加上存储 API 的复杂性，这个过程也是困难的</li><li>恰好一次执行。旨在可靠的处理事件的触发存储器实际上并不能保证一次性执行。例如，当一个触发器触发一个函数处理消息队列中所有的消息的时候，就会带来消息的重复消费</li><li>同步性。并发控制必须通过外部服务来实现。租约迫使开发商根据时间假设进行工作，而电子标签只能检测冲突，而不能阻止冲突</li></ul><h3 id="相关工作-4"><a href="#相关工作-4" class="headerlink" title="相关工作"></a>相关工作</h3><ul><li>两种常见的有状态的 Serverless 抽象是 workflow 以及 actor<ul><li>Workflow<ul><li>Amazon Step functions</li><li>Azure Durable Functions</li><li>IBM Composer</li></ul></li><li>Actor<ul><li>Orleans</li><li>Durable Objects</li><li>Akka Serverless</li><li>Azure Durable Entities</li></ul></li></ul></li></ul><h2 id="The-Serverless-Trilemma-Function-Composition-for-Serverless-Computing"><a href="#The-Serverless-Trilemma-Function-Composition-for-Serverless-Computing" class="headerlink" title="The Serverless Trilemma Function Composition for Serverless Computing"></a><a href="https://dl.acm.org/doi/pdf/10.1145/3133850.3133855">The Serverless Trilemma Function Composition for Serverless Computing</a></h2><h3 id="解决问题-5"><a href="#解决问题-5" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>描述了 Serverless 计算中关于函数组合的困难：Serverless trilemma<ul><li>函数需要在黑盒中进行</li><li>维护函数调用的可替代性原则</li><li>避免重复付费</li></ul></li></ul><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>在论文《The Serverless Trilemma: Function Composition for Serverless Computing》中的“Serverless Computing 简介”章节，提到了几个关键的概念和实践，以下是对这些概念的介绍：</p><ol><li><strong>Serverless Computing（无服务器计算）</strong>: 这一部分通过一个实例来介绍无服务器计算的价值提案。它描述了如何通过事件驱动的数据管道将两个现有服务连接起来。具体例子中，应用程序监控 Travis（持续集成工具）的构建失败，并通过 Slack（消息服务平台）发送通知。</li><li><strong>Functions as a Service（<strong><strong>函数即服务</strong></strong>，FaaS）</strong>: 描述了如何使用函数来响应特定事件。例如，在 Travis 构建完成时触发事件，这时需要一个用于数据格式转换的函数（Format），以及一个用于向 Slack 发送通知的函数（Post）。这些函数作为独立的单元被部署和调用，而不需要预先配置基础设施。</li><li><strong>Event-Driven Invocation（事件驱动调用）</strong>: 描述了如何基于特定事件（如 Travis 构建完成）触发函数调用。这类调用通常通过发布-订阅系统来实现，其中 OpenWhisk 使用触发器（trigger）来代表一个命名的话题。</li><li><strong>Componentization and Composition（组件化和组合)</strong>: 论文强调了将功能分解为更小、更专注的函数的重要性，这不仅促进了代码重用，也简化了整体架构。这部分讨论了如何在无服务器运行时环境中实现函数的组合，以及如何将一个函数的输出作为另一个函数的输入。</li></ol><h3 id="反应式模型"><a href="#反应式模型" class="headerlink" title="反应式模型"></a>反应式模型</h3><p>该章节描述了 OpenWhisk 的编程模型，刻画了反应式模型在 OpenWhisk 中的应用</p><ol><li><strong>OpenWhisk 编程模型</strong>: 这一节为论文的其他部分奠定了基础，通过介绍 OpenWhisk 的核心编程模型。OpenWhisk 是一个开源的无服务器平台，其核心特性包括反应式调度器和反射能力。</li><li><strong>反应式调度器(<strong><strong>reactive</strong></strong> scheduler)</strong>: OpenWhisk 的核心包括一个反应式调度器，用于调度单一的、完整的动作（actions）。这种调度方式是基于事件驱动的，意味着动作的执行是由外部事件触发的。</li><li><strong>反射能力(reflective capability)</strong>: 通过反射调用（reflective invocation），一个动作可以控制其他动作的调度。这意味着在 OpenWhisk 中，一个函数可以触发或控制另一个函数的执行。</li><li><strong>外部调度器的能力与限制</strong>: 第四节将展示这种类型的外部调度器的能力与限制，其中“外部调度器”指的是不属于 OpenWhisk 核心部分的实体，它管理动作的调用。在这种情况下，程序完全利用核心调度器进行操作，这些程序被称为静态或静态调度程序。</li><li><strong>模型的抽象语法</strong>: 论文中还描述了该模型的抽象语法的语法表，从这个模型中可以直接映射到 OpenWhisk 的实际编程实践。</li></ol><p><img src="/../assets/FUeqbOFuHoswTYx6dgbclH28nMc.png"></p><ol><li><strong>触发器(triggers)<strong>：模型使用触发器来表示事件。一个程序包含了一个或者多个规则，一个规则描述了一个触发器</strong>何时</strong>执行并且<strong>执行什么</strong>；</li></ol><h4 id="OpenWhisk-Actions"><a href="#OpenWhisk-Actions" class="headerlink" title="OpenWhisk Actions"></a>OpenWhisk Actions</h4><ol><li><strong>Stateless Function</strong>: OpenWhisk 中的动作（Action）被定义为一个无状态的函数，每个动作都有一个唯一的名称。</li><li><strong>输入与输出</strong>: 动作的输入是一个字典（Dictionary），即一组键值对。动作的输出是另一个字典（如果动作成功完成），或者是一个失败的指示。这里采用了 Scala 的 Try 类型，表示动作调用的结果可能是成功的类型 T 或者是系统的错误类型。一个 Action 可以通过下列公式进行表示</li></ol><p>$$<br>a.invoke: Dictionary \rightarrow Try[Dictionary]<br>$$</p><ol><li><p><strong>日志输出</strong>: 除了正常的响应外，动作也可能产生日志输出的副通道。一个动作的日志被认为是一个可能为空的日志记录列表。为了性能考虑，日志记录仅在事后可访问。</p></li><li><p><strong>无状态性（Statelessness）</strong>: 一个 action 不能假设从一个调用到下一个调用会<strong>持续存在词法状态</strong>。这种无状态性简化了调度和扩展的解决方案</p><ol><li>如果需要将状态传递给未来的调用，action 负责安排适当的外部机制。例如，状态可以外部化到托管的文档存储，如 Amazon 的 S3 或 IBM 的 Cloudant。</li></ol></li><li><p><strong>最多一次调用语义（At-Most-Once Invocation Semantics）</strong>: 在分布式系统中，无法保证完全准确一次的传递。因此，实现只需保证最多一次的语义，即每次动作的调用。</p></li></ol><h4 id="柯里化函数应用"><a href="#柯里化函数应用" class="headerlink" title="柯里化函数应用"></a>柯里化函数应用</h4><p>在论文《The Serverless Trilemma: Function Composition for Serverless Computing》中提到的“Curried Function Application”（柯里化函数应用）是指在无服务器计算环境中，将特定的值（键值对）绑定到一个函数上，从而创建一个新的函数版本的过程。</p><p>具体来说，当你有一个动作（函数）<code>a</code> 和一组键值对 <code>M</code> 时，你可以通过将 <code>a</code> 根据 <code>M</code> 中的变量赋值进行柯里化，来创建一个新的动作 <code>a&#39;</code>。这个过程被称为 <code>a.with(M)</code>。结果产生的动作 <code>a&#39;</code> 被视为 <code>a</code> 的一个绑定版本。</p><p>操作上，如果你调用 <code>a.with(M).invoke(D)</code>，你实际上是在调用一个与映射 <code>M</code> 柯里化并且用实际参数 <code>D</code> 调用的动作。</p><p>柯里化函数应用在无服务器架构中特别有用，因为它允许动态地创建具有特定配置的函数版本，而无需为每种可能的配置编写单独的代码。这种方法提高了代码的复用性，并简化了在无服务器环境中函数组合的处理。</p><h4 id="包：命名空间与批量柯里化"><a href="#包：命名空间与批量柯里化" class="headerlink" title="包：命名空间与批量柯里化"></a>包：命名空间与批量柯里化</h4><ol><li>命名空间和动作分组: OpenWhisk 允许将动作（Actions）在特定的命名空间下进行分组。这种分组以包（Package）的形式出现，一个包 <code>P</code> 是一组动作 <code>Ap</code> 的集合。</li><li>批量柯里化: 包中的动作可以通过 <code>with</code> 绑定组合。例如，对于包 <code>P</code> 和其中的动作 <code>a</code>，调用 <code>P.with(Mp).a.with(Ma).invoke(P)</code> 表示首先应用包级别的变量赋值 <code>Mp</code>，然后是动作级别的 <code>Ma</code>，最后是实际参数。这样的处理方式使得变量赋值 <code>Mp</code> 在实际参数和动作级别柯里化之后，作为第三优先级来源。</li><li>抽象和隔离: 包的柯里化提供了一个有用的抽象，特别是在处理凭证和其他秘密信息时。绑定允许程序隔离凭证，以便它们只暴露给需要它们的动作。</li></ol><h4 id="OpenWhisk-Triggers"><a href="#OpenWhisk-Triggers" class="headerlink" title="OpenWhisk Triggers"></a>OpenWhisk Triggers</h4><ol><li>消息队列的表示: OpenWhisk 的编程模型将消息队列表现为两种操作，这些操作是基于命名主题的，称为触发器（triggers）。</li><li>触发器类型构造: 使用类型构造函数 <code>Trigger[t]</code>，可以构建一个新的触发器子类型，其中 <code>t</code> 是应用程序中识别主题的字符串。</li><li>触发器代表消息类: 触发器 <code>Trigger[t]</code> 代表一类消息，可以简单地表示为 <code>t</code>。消息被认为是字典类型（Dictionary），与动作的输入和输出格式相同。</li><li>创建和通知消息: 对于给定主题 <code>t</code> 和有效载荷 <code>D</code>，<code>t.fire(D)</code> 操作用于构造一个带有此有效载荷的新消息，并通知消息队列其到达。例如，要在 “build_done” 主题上创建表示成功构建的消息，可以使用 <code>Trigger[&quot;build_done&quot;].fire(status → &quot;success&quot;)</code>。</li></ol><h4 id="通过触发器进行反应式调用"><a href="#通过触发器进行反应式调用" class="headerlink" title="通过触发器进行反应式调用"></a>通过触发器进行反应式调用</h4><p>我们已经介绍了触发器(trigger)以及动作(action)，他们直接通过一个 <code>when</code> 的语法进行连接。</p><p><img src="/../assets/serverless_workflow/DTyibRzCconL1Lxg0CjchBLfnJh.png"></p><ul><li>规则(Rule): 描述了从触发器到动作之间的联系。<code>t.when(a)</code><ul><li>包含多个状态位：决定了 t 是否发送消息</li><li>允许程序分离他们对于 actions 触发的管理</li></ul></li></ul><h4 id="部署与反思"><a href="#部署与反思" class="headerlink" title="部署与反思"></a>部署与反思</h4><ol><li>动作部署（Deployment）: 当一个动作的源代码准备好后，它可以被部署。只有在部署之后，这个动作才可以被调用。每个已部署的动作都有一个独特的远程调用端点。</li><li>触发器部署: 类似地，一旦触发器（Trigger）被部署，它也会收到一个独特的远程触发端点。</li><li>反射式调用（Reflective Invocation）: 使用这些远程端点，一个动作在其调用期间可以调用另一个动作。这种动作调用动作的过程被称为反射式调用。</li><li>内省功能（Introspective Facilities）: 这些内省功能允许在核心提供的组合器之外，使用一般用途语言的全部功能进行新类型组合器的实验。通过对静态组合的属性进行内省，可以将新的组合器作为无服务器动作编程。</li><li>内省 API: 论文假设内省 API 以 JavaScript 库的形式呈现，可供实现为 JavaScript 的无服务器动作使用。为了清晰的展示，将使用由核心模型提供的内省函数的符号表示，这些包括动作、触发器和规则函数，它们分别代表各自实体的构造器。这些反射式构造器允许进行元编程，这是论文后续将更详细探讨的一个场景。</li></ol><h3 id="The-Serverless-Trilemma"><a href="#The-Serverless-Trilemma" class="headerlink" title="The Serverless Trilemma"></a>The Serverless Trilemma</h3><ol><li>序列组合的引入: 在核心模型中，序列组合允许程序从两个给定的动作中构造一个新的动作。这种新动作的调用含义将通过 flatMap 单子组合的语义来精确定义：序列表现为数据管道，其中唯一的隐式通信发生在动作间的连接点，且在第一个失败的动作处执行短路。</li><li>序列组合器“then”: 作者引入了一个所期望的序列组合器，称为“then”。例如，组合 <code>a.then(b).then(c)</code> 应该等同于一个新的动作 <code>s</code>，使得输入到 <code>s</code> 的内容成为输入到 <code>a</code> 的内容，而 <code>s</code> 的输出与表达式 <code>c(b(a()))</code> 的输出相同。</li></ol><h4 id="双重计费约束"><a href="#双重计费约束" class="headerlink" title="双重计费约束"></a>双重计费约束</h4><p>文章首先定义了什么是双重计费，即一个函数调用另一个函数的时候，该调用函数必须等待被调用函数执行完毕才停止，带来了执行时间上的浪费问题</p><p><img src="/../assets/serverless_workflow/TuPQbU3Xdox42IxIDI6ca8WPnHd.png"></p><h4 id="黑盒约束"><a href="#黑盒约束" class="headerlink" title="黑盒约束"></a>黑盒约束</h4><ul><li>函数流上的多个函数需要能够支持不同语言的函数执行</li><li>函数需要通过 Action 进行触发</li></ul><h4 id="可替代原则"><a href="#可替代原则" class="headerlink" title="可替代原则"></a>可替代原则</h4><p>希望动作的组合本身就是动作。以下是可能得解决方案</p><ol><li><p>反射调用</p><ol><li>使用调度程序调用多个函数，但是调度程序在其组成部分的活动时间内要保持活跃状态，带来双重计费</li></ol></li><li><p>连续传递</p><ol><li>通过让操作调用延续（即序列的其余部分）来调度序列。</li><li>该方法使用 <code>triggers</code> 和 <code>rules</code> 来实现</li><li>通过关联每个完成触发器与每个动作，当一个动作的调用完成时，调用会触发被关联的完全触发器。例如一个序列$a.then(b)$,a 的一个完全触发器被表示为$ct(a)$,那么就创建一个规则$ct(a).when(b)$。当 a 的完全触发器被调用时，就计划一个对于 b 的调用</li><li>当通过触发调用实现函数组合时，这种连续性可能会被破坏，因为触发的调用<strong>往往涉及到<strong><strong>异步处理</strong></strong>和事件驱动的机制</strong>。这可能意味着当一个函数调用另一个函数时，后者可能不会立即执行，而是在满足某些条件或接收到特定事件时才触发。这种行为的差异可能导致无法保持原始的同步调用模式，从而违反了可替代原则。<br>在这样的场景中，组合的函数无法简单地被视为相互替代的，因为它们的执行依赖于外部事件或触发器，而不仅仅是输入参数。这种异步性和依赖于事件的特性使得函数的组合变得更加复杂，并引入了额外的考虑因素，如状态管理、事件处理和调用顺序的控制。</li></ol></li><li><p>客户端调度程序</p><ol><li>当前仅当客户端程序实现了所有在 OpenWhisk 中可能的组合，该方法才算实现了可替代原则</li></ol></li></ol><h3 id="OpenWhisk-Invocation-Flow"><a href="#OpenWhisk-Invocation-Flow" class="headerlink" title="OpenWhisk Invocation Flow"></a>OpenWhisk Invocation Flow</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>包含了 4 个组件</p><p><img src="/../assets/serverless_workflow/DSBCbxR8ooLUF6xPamYcNmOWnfe.png"></p><p>当一个调用请求到来时</p><ol><li><code>controller</code> 首先选择 hosts 池子中的一个 <code>invoker</code></li><li>将请求信息放到一个 <code>message queue</code> 中</li><li>每个 <code>invoker</code> 都托管了多个容器，将多个调用分离开</li><li><code>invoker</code> 订阅了指向他们的事件，当资源可用时，将调用请求注入到容器中，此时，调用开始</li><li>当一个调用结束时，<code>invoker</code> 将结果存储到 <code>system of record</code> 中，向控制器指示它现在可以响应客户端</li></ol><h4 id="Active-ack"><a href="#Active-ack" class="headerlink" title="Active ack"></a>Active ack</h4><ul><li>管道旁路的微架构策略</li></ul><p><img src="/../assets/serverless_workflow/OpgobpKlxoUeVbxd5HccFkHsnWf.png"></p><p>调用者以绕过系统记录的方式发出完成信号。<code>ack action</code> 使用消息队列作为计分板，将调用者的结果转发到控制器，以便控制器可以在调用完成时快速采取行动。</p><h4 id="Active-ACK-应用"><a href="#Active-ACK-应用" class="headerlink" title="Active ACK 应用"></a>Active ACK 应用</h4><p>通过应用 Active ACK 后，将发生如下的变化</p><ol><li>创建一个 <code>action</code> 的时候，必须指定该 <code>action</code> 为序列，然后指定构成组合的组件 OpenWhisk actions</li><li>控制器必须特殊处理序列 <code>action</code> 的调用</li></ol><p><img src="/../assets/serverless_workflow/BEvob9xv5oLYXNxz5U9cPSoAnWg.png"></p><p>在处理序列的调用时，在收到主动确认后，控制器会排列序列中下一个操作的调用。重复此排队调用和主动确认消息的循环，直到控制器到达操作列表的末尾。此时，它用最终的主动确认负载响应客户端。</p><h3 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h3><p>对序列之外的组合模式的需求，有三类这样的组合器：ECA 模型、重试以及数据转发。</p><p><img src="/../assets/serverless_workflow/FQXgbU5o5oTsAfxCFLCcLwmOn1c.png"></p><h4 id="ECA"><a href="#ECA" class="headerlink" title="ECA"></a>ECA</h4><p>来自 Travis 的通知消息包含无关的详细信息。因此，应用程序在步骤 1 中投影出相关字段：构建标识符和构建状态。如果构建失败（步骤 2），应用程序将继续执行步骤 3。</p><p>为了实现 ECA 这样的模型，下列代码展示了一个组合器，通过 condition 以及 action。当提供了入参 args 时，它将触发条件。</p><p><img src="/../assets/serverless_workflow/JG2jbcdMJoljKxxC7qEcr3pqnAb.png"></p><h4 id="元程序重试"><a href="#元程序重试" class="headerlink" title="元程序重试"></a>元程序重试</h4><p>为了重试，我们可以编写一个元程序，将函数作为输入，并调用它直到成功。清单 5 说明了这个重试元程序。我们想要的 VerifyAndAnalyze 函数现在可以表示为 Retry 的绑定，其中操作参数 A 绑定到 VerifyThenAnalyze。</p><p><img src="/../assets/serverless_workflow/Q3sObQMVAowi7Mx8WzDc2Ls2nmc.png"></p><h4 id="元程序数据转发"><a href="#元程序数据转发" class="headerlink" title="元程序数据转发"></a>元程序数据转发</h4><p>图中步骤 3 的输出(a,b)其中之一将进入到步骤 4 跟 5，另一个需要在 4 跟 5 执行后跟着 c 一起呗转发到 6，由于从 Retry action 返回的值还未实现，因此只能通过下列代码进行</p><p><img src="/../assets/serverless_workflow/Kq8rbg0g3o8iUexQ8rjcZ6UnnjS.png"></p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Serverless</tag>
      
      <tag>Function orchestration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes 学习笔记</title>
    <link href="/2023/10/29/kubernetes/"/>
    <url>/2023/10/29/kubernetes/</url>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes-概述"><a href="#Kubernetes-概述" class="headerlink" title="Kubernetes 概述"></a>Kubernetes 概述</h1><ul><li>k8s 官网：<a href="https://kubernetes.io/">https://kubernetes.io/</a></li></ul><p>Kubernetes 又被叫做 k8s，是一个用于自动化部署、自动扩容以及容器化应用管理的开源系统</p><h1 id="kubernetes-搭建"><a href="#kubernetes-搭建" class="headerlink" title="kubernetes 搭建"></a><code>kubernetes</code> 搭建</h1><p>使用阿里云的镜像构建 k8s</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https<br>curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add -<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/OQ4Ib3kX8oPLdMxC3MZcdZmmnNf.png"></p><p>之后将阿里云的镜像地址写到 sources.list 当中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/apt/sources.list.d/kubernetes.list<br><br><span class="hljs-comment"># 写入下列内容</span><br>deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main<br></code></pre></td></tr></table></figure><p>退出后更新软件包，下载 k8s</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get install -y kubelet kubeadm kubectl<br></code></pre></td></tr></table></figure><h1 id="kubernetes-工具搭建"><a href="#kubernetes-工具搭建" class="headerlink" title="kubernetes 工具搭建"></a><code>kubernetes</code> 工具搭建</h1><p>通过上述流程其实已经安装好了 <code>kubelet</code>、<code>kubeadm</code> 以及 <code>kubectl</code>。如果没有安装就参照下列文档</p><h2 id="kubectl"><a href="#kubectl" class="headerlink" title="kubectl"></a><code>kubectl</code></h2><h3 id="kubectl-安装"><a href="#kubectl-安装" class="headerlink" title="kubectl 安装"></a><code>kubectl</code> 安装</h3><p>kubectl 是一个能够在 k8s 集群中运行命令的工具</p><ol><li>下载最新的 <code>kubectl</code> 发行版</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -LO <span class="hljs-string">&quot;https://dl.k8s.io/release/<span class="hljs-subst">$(curl -L -s https://dl.k8s.io/release/stable.txt)</span>/bin/linux/amd64/kubectl&quot;</span><br></code></pre></td></tr></table></figure><ol><li>验证 <code>kubectl</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -LO <span class="hljs-string">&quot;https://dl.k8s.io/<span class="hljs-subst">$(curl -L -s https://dl.k8s.io/release/stable.txt)</span>/bin/linux/amd64/kubectl.sha256&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(cat kubectl.sha256)</span>  kubectl&quot;</span> | <span class="hljs-built_in">sha256sum</span> --check<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/FKQlbkSaaotYn8xgznecx9pqnyg.png"></p><ol><li>安装 kubectl</li></ol><p>由于我不想安装在根目录中（考虑到系统应当保持对普通用户的最小权限），因此将 <code>kubectl</code> 安装为普通用户模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p ~/.local/bin/<br><span class="hljs-built_in">mv</span> ./kubectl ~/.local/bin/<br></code></pre></td></tr></table></figure><ol><li>验证 <code>kubectl</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl version --client<br><br>kubectl version --client --output=yaml<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/CmacbNQiVowWpwxOpDJcosoenHc.png"></p><h3 id="kubectl-配置"><a href="#kubectl-配置" class="headerlink" title="kubectl 配置"></a><code>kubectl</code> 配置</h3><p>为了使得 <code>kubectl</code> 能够找到并且感知一个 k8s 集群，它需要一个 <code>kubeconfig file</code>，其在使用 <code>kube-up.sh</code> 创建一个集群或者成功部署一个 <code>Minikube</code> 集群的时候会自动创建。默认情况下，<code>kubeconfig</code> 配置会放在 <code>~/.kube/config</code></p><ol><li>通过集群的状态可以检查 <code>kubectl</code> 是否已经配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl cluster-info<br></code></pre></td></tr></table></figure><h2 id="kubeadm"><a href="#kubeadm" class="headerlink" title="kubeadm"></a><code>kubeadm</code></h2><h3 id="配置-CA-证书"><a href="#配置-CA-证书" class="headerlink" title="配置 CA 证书"></a>配置 CA 证书</h3><ol><li>下载 <code>easyrsa3</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -LO https://dl.k8s.io/easy-rsa/easy-rsa.tar.gz<br>tar xzf easy-rsa.tar.gz<br><span class="hljs-built_in">cd</span> easy-rsa-master/easyrsa3<br>./easyrsa init-pki<br></code></pre></td></tr></table></figure><ol><li>生成一个新的 CA</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./easyrsa --batch <span class="hljs-string">&quot;--req-cn=<span class="hljs-variable">$&#123;MASTER_IP&#125;</span>@`date +%s`&quot;</span> build-ca nopass<br></code></pre></td></tr></table></figure><ol><li>生成服务器证书和密钥</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">./easyrsa --subject-alt-name=<span class="hljs-string">&quot;IP:<span class="hljs-variable">$&#123;MASTER_IP&#125;</span>,&quot;</span>\<br><span class="hljs-string">&quot;IP:<span class="hljs-variable">$&#123;MASTER_CLUSTER_IP&#125;</span>,&quot;</span>\<br><span class="hljs-string">&quot;DNS:kubernetes,&quot;</span>\<br><span class="hljs-string">&quot;DNS:kubernetes.default,&quot;</span>\<br><span class="hljs-string">&quot;DNS:kubernetes.default.svc,&quot;</span>\<br><span class="hljs-string">&quot;DNS:kubernetes.default.svc.cluster,&quot;</span>\<br><span class="hljs-string">&quot;DNS:kubernetes.default.svc.cluster.local&quot;</span> \<br>--days=10000 \<br>build-server-full server nopass<br></code></pre></td></tr></table></figure><ol><li>拷贝 <code>pki/ca.crt</code>, <code>pki/issued/server.crt</code>, and <code>pki/private/server.key</code> 到特定目录.</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">dydy@dydy-PC:~/Downloads/easy-rsa-master/easyrsa3/pki$ sudo <span class="hljs-built_in">cp</span> ./ca.crt /etc/kubernetes/pki/ca.crt<br>dydy@dydy-PC:~/Downloads/easy-rsa-master/easyrsa3/pki$ sudo <span class="hljs-built_in">cp</span> ./private/ca.key /etc/kubernetes/pki/ca.key<br></code></pre></td></tr></table></figure><h2 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a><code>kubelet</code></h2><h3 id="通过配置文件设置-kubelet-参数"><a href="#通过配置文件设置-kubelet-参数" class="headerlink" title="通过配置文件设置 kubelet 参数"></a><a href="https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/">通过配置文件设置</a> <code>kubelet</code> <a href="https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/">参数</a></h3><ol><li>创建配置文件</li></ol><p>我们在 <code>kubelet</code> 看得到的地方创建一个配置文件，以下是一个示例</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kubelet.config.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">KubeletConfiguration</span><br><span class="hljs-attr">address:</span> <span class="hljs-string">&quot;192.168.0.8&quot;</span><br><span class="hljs-attr">port:</span> <span class="hljs-number">20250</span><br><span class="hljs-attr">serializeImagePulls:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">evictionHard:</span><br>    <span class="hljs-attr">memory.available:</span>  <span class="hljs-string">&quot;200Mi&quot;</span><br></code></pre></td></tr></table></figure><ol><li>通过配置文件启动进程</li></ol><h1 id="kubernetes-容器运行时-container-runtimes"><a href="#kubernetes-容器运行时-container-runtimes" class="headerlink" title="kubernetes 容器运行时(container runtimes)"></a><code>kubernetes</code> 容器运行时(container runtimes)</h1><p>本章节主要讲述了设置结点的相关任务</p><p>主要的安装软件包括</p><ul><li><code>containerd</code></li><li><code>CRI-O</code></li><li><code>Docker Engine</code></li><li><code>Mirantis Container Runtime</code></li></ul><h2 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h2><ol><li>转发 IPV4 并且让 <code>iptables</code> 能够看到桥接流量</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /etc/modules-load.d/<br><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">EOF | sudo tee ./k8s.conf</span><br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/UF6dbZiWwonpkOxXnNkcMXB5nGg.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo modprobe overlay<br>sudo modprobe br_netfilter<br><br><span class="hljs-comment"># sysctl params required by setup, params persist across reboots</span><br><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF | sudo tee /etc/sysctl.d/k8s.conf</span><br><span class="hljs-string">net.bridge.bridge-nf-call-iptables  = 1</span><br><span class="hljs-string">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="hljs-string">net.ipv4.ip_forward                 = 1</span><br><span class="hljs-string">EOF</span><br><span class="hljs-comment"># Apply sysctl params without rebootsudo sysctl --system</span><br><br>sudo sysctl --system<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/AvQDb0KqEon2TlxQWuLcdlo8nvh.png"></p><p>验证 <code>br_netfilter</code> 以及 <code>overlay</code> 模块是否已经被加载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsmod | grep br_netfilter<br>lsmod | grep overlay<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/NoJvbLRguoqrVuxZP5RcaKfInxb.png"></p><p>验证 <code>net.bridge.bridge-nf-call-iptables</code>, <code>net.bridge.bridge-nf-call-ip6tables</code>, and <code>net.ipv4.ip_forward</code> 这些系统变量都被设置为 1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sysctl net.bridge.bridge-nf-call-iptables net.bridge.bridge-nf-call-ip6tables net.ipv4.ip_forward<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/Vc21bvHmlonR0NxUCMOc7j6Anqc.png"></p><h2 id="cgroup-驱动"><a href="#cgroup-驱动" class="headerlink" title="cgroup 驱动"></a><code>cgroup</code> 驱动</h2><p>在 Linux 系统下，控制组（<code>control groups</code>）被用来管理附加在进程上的资源</p><p><code>kubelet</code> 以及我们所需要安装的工具都需要通过实现 <code>control groups</code> 来促使 <code>pods &amp; containers</code> 的资源管理以及设置资源限制。为了通过 <code>control groups</code> 实现，<code>kubelet</code> 以及容器运行时需要使用 <code>cgroup drivers</code>。需要强调的是 <code>kubelet</code> 以及容器运行时使用的是相同的 <code>cgroup</code> 驱动以及拥有着相同的配置</p><ul><li><code>cgroupfs</code></li><li><code>systemd</code></li></ul><h3 id="cgroupfs-驱动"><a href="#cgroupfs-驱动" class="headerlink" title="cgroupfs 驱动"></a><code>cgroupfs</code> 驱动</h3><p><code>cgroupfs driver</code> 是默认的 <code>kubelet cgroup</code> 驱动。通过使用 <code>cgroupfs</code> 驱动，<code>kubelet</code> 以及容器运行时就可以直接实现 <code>cgroup</code> 文件系统来配置 <code>cgroups</code></p><p><code>cgroups</code> 驱动在 <code>systemd</code> 已经在系统最开始就安装的情况下是不推荐的，因为 <code>systemd</code> 希望系统中只有一个单独的 <code>cgroup</code> 管理者</p><h3 id="systemd-cgroup-驱动"><a href="#systemd-cgroup-驱动" class="headerlink" title="systemd cgroup 驱动"></a><code>systemd</code> <code>cgroup</code> 驱动</h3><p>前面我们提到，当系统初始化时已经使用了 <code>systemd</code> 作为系统资源的管理者时，便不再使用 <code>cgroupfs</code>，否则系统将会有两个不同的资源管理器，带来的后果如下</p><blockquote><p>Two <code>cgroup</code> managers result in two views of the available and in-use resources in the system. In some cases, nodes that are configured to use <code>cgroupfs</code> for the kubelet and container runtime, but use <code>systemd</code> for the rest of the processes become unstable under resource pressure.</p></blockquote><p>因此当 <code>systemd</code> 在系统初始化时已经被用于管理系统资源，我们使用 <code>systemd</code> 作为 <code>kubelet</code> 以及容器运行时的 <code>cgroup</code> 驱动。</p><p>为了将 <code>systemd</code> 设置为 <code>cgroup</code> 驱动，通过编辑 <code>KubeletConfiguration</code> 选项来设置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kubelet.config.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">KubeletConfiguration</span><br><span class="hljs-string">...</span><br><span class="hljs-attr">cgroupDriver:</span> <span class="hljs-string">systemd</span><br></code></pre></td></tr></table></figure><h3 id="将-systemd-驱动迁移至-kubdeam-管理的集群"><a href="#将-systemd-驱动迁移至-kubdeam-管理的集群" class="headerlink" title="将 systemd 驱动迁移至 kubdeam 管理的集群"></a>将 <code>systemd</code> 驱动迁移至 <code>kubdeam</code> 管理的集群</h3><p>本章节主要介绍如何通过默认的 <code>systemd</code> 驱动建立不同的容器运行时</p><h4 id="配置-kubelet-的-cgroup-驱动"><a href="#配置-kubelet-的-cgroup-驱动" class="headerlink" title="配置 kubelet 的 cgroup 驱动"></a>配置 <code>kubelet</code> 的 <code>cgroup</code> 驱动</h4><p><code>kubeadm</code> 允许用户在使用 <code>kubeadm init</code> 时传入一个 <code>kubeletConfiguration</code> 数据结构。这个结构可以包括 <code>cgroupDriver</code> 字段来控制 <code>kubelet</code> 的 <code>cgroup</code> 驱动</p><p>一个最简单的配置字段的例子</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># kubeadm-config.yaml</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterConfiguration</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kubeadm.k8s.io/v1beta3</span><br><span class="hljs-attr">kubernetesVersion:</span> <span class="hljs-string">v1.21.0</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">KubeletConfiguration</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kubelet.config.k8s.io/v1beta1</span><br><span class="hljs-attr">cgroupDriver:</span> <span class="hljs-string">systemd</span><br></code></pre></td></tr></table></figure><p>可以通过以下的启动命令进行传递</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubeadm init --config kubeadm-config.yaml<br></code></pre></td></tr></table></figure><h2 id="容器运行时"><a href="#容器运行时" class="headerlink" title="容器运行时"></a>容器运行时</h2><h3 id="containerd"><a href="#containerd" class="headerlink" title="containerd"></a><code>containerd</code></h3><blockquote><p><strong>FAQ</strong>: For Kubernetes, do I need to download <code>cri-containerd-(cni-)&lt;VERSION&gt;-&lt;OS-&lt;ARCH&gt;.tar.gz</code> too?<br><strong>Answer</strong>: No.<br>As the Kubernetes CRI feature has been already included in <code>containerd-&lt;VERSION&gt;-&lt;OS&gt;-&lt;ARCH&gt;.tar.gz</code>, you do not need to download the <code>cri-containerd-....</code> archives to use CRI.<br>The <code>cri-containerd-...</code> archives are <a href="https://github.com/containerd/containerd/blob/main/RELEASES.md#deprecated-features">deprecated</a>, do not work on old Linux distributions, and will be removed in containerd 2.0.</p><p>…非常抽象</p></blockquote><ol><li>安装 <code>containerd</code></li></ol><p>通过<u><a href="https://github.com/containerd/containerd/releases">https://github.com/containerd/containerd/releases</a></u> 下载对应版本的 <code>containerd</code> 并解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo tar Cxzvf /usr/local/ containerd-1.6.24-linux-amd64.tar.gz<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/TlWmbH8bMoDbS0xPUNqcfw8wnsd.png"></p><p><strong>systemd</strong></p><p>为了使用 <code>systemd</code> 启动 <code>containerd</code>，我们应该通过 <a href="https://raw.githubusercontent.com/containerd/containerd/main/containerd.service">https://raw.githubusercontent.com/containerd/containerd/main/containerd.service</a> 下载配置文件到 <code>/usr/local/lib/systemd/system</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dydy@dydy-PC:/usr/local/lib/systemd/system$ curl https://erd/main/containerd.service | sudo <span class="hljs-built_in">tee</span> /usr/local/lib/systemd/system/containerd.service<br></code></pre></td></tr></table></figure><p>然后运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl daemon-reload<br>systemctl <span class="hljs-built_in">enable</span> --now containerd<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/QkoxbqXUioGzWnxwd7ocef0LnRc.png"></p><ol><li>安装 <code>runc</code></li></ol><p>从 <a href="https://github.com/opencontainers/runc/releases">https://github.com/opencontainers/runc/releases</a> 下载二进制文件，然后执行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo install -m 755 runc.amd64 /usr/local/sbin/runc<br></code></pre></td></tr></table></figure><ol><li>安装 CNI 插件</li></ol><p>从 <a href="https://github.com/containernetworking/plugins/releases">https://github.com/containernetworking/plugins/releases</a> 下载二进制文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> -p /opt/cni/bin/<br>sudo tar Cxzvf /opt/cni/bin/ cni-plugins-linux-amd64-v1.3.0.tgz<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/L2bxbVLLCorH2hx1AgQcseELngh.png"></p><p>安装完成后，会在 <code>/etc/containerd/config.toml</code> 当中看到配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#   Copyright 2018-2022 Docker Inc.</span><br><br><span class="hljs-comment">#   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="hljs-comment">#   you may not use this file except in compliance with the License.</span><br><span class="hljs-comment">#   You may obtain a copy of the License at</span><br><br><span class="hljs-comment">#       http://www.apache.org/licenses/LICENSE-2.0</span><br><br><span class="hljs-comment">#   Unless required by applicable law or agreed to in writing, software</span><br><span class="hljs-comment">#   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="hljs-comment">#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="hljs-comment">#   See the License for the specific language governing permissions and</span><br><span class="hljs-comment">#   limitations under the License.</span><br><br><span class="hljs-string">disabled_plugins</span> <span class="hljs-string">=</span> [<span class="hljs-string">&quot;cri&quot;</span>]<br><br><span class="hljs-comment">#root = &quot;/var/lib/containerd&quot;</span><br><span class="hljs-comment">#state = &quot;/run/containerd&quot;</span><br><span class="hljs-comment">#subreaper = true</span><br><span class="hljs-comment">#oom_score = 0</span><br><br><span class="hljs-comment">#[grpc]</span><br><span class="hljs-comment">#  address = &quot;/run/containerd/containerd.sock&quot;</span><br><span class="hljs-comment">#  uid = 0</span><br><span class="hljs-comment">#  gid = 0</span><br><br><span class="hljs-comment">#[debug]</span><br><span class="hljs-comment">#  address = &quot;/run/containerd/debug.sock&quot;</span><br><span class="hljs-comment">#  uid = 0</span><br><span class="hljs-comment">#  gid = 0</span><br><span class="hljs-comment">#  level = &quot;info&quot;</span><br></code></pre></td></tr></table></figure><p>然后将默认的配置文件写入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">containerd config default | sudo <span class="hljs-built_in">tee</span> /etc/containerd/config.toml<br></code></pre></td></tr></table></figure><p>为了在配置里头通过 <code>runc</code> 使用 <code>systemd</code> <code>cgroup</code> 驱动，进行如下设置</p><p><img src="/../assets/kubernetes/CZrubBOzuojoPUx4MA8czbb9nPd.png"></p><p>然后重启 <code>containerd</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl restart containerd<br></code></pre></td></tr></table></figure><h3 id="CRI-O"><a href="#CRI-O" class="headerlink" title="CRI-O"></a><code>CRI-O</code></h3><h3 id="Docker-Engine"><a href="#Docker-Engine" class="headerlink" title="Docker Engine"></a><code>Docker Engine</code></h3><h3 id="Mirantis-Container-Runtime"><a href="#Mirantis-Container-Runtime" class="headerlink" title="Mirantis Container Runtime"></a><code>Mirantis Container Runtime</code></h3><h1 id="kubernetes-部署运行"><a href="#kubernetes-部署运行" class="headerlink" title="kubernetes 部署运行"></a><code>kubernetes</code> 部署运行</h1><h2 id="Hello-Minikube"><a href="#Hello-Minikube" class="headerlink" title="Hello Minikube"></a><a href="https://kubernetes.io/docs/tutorials/hello-minikube/">Hello Minikube</a></h2><ol><li>事先准备<ol><li>建立 <code>minikube</code><ol><li>下载安装</li></ol></li></ol></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64<br>sudo install minikube-linux-amd64 /usr/local/bin/minikube<br></code></pre></td></tr></table></figure><ol><li>启动集群</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube start<br></code></pre></td></tr></table></figure><p>报错</p><blockquote><p>You appear to be using a proxy, but your NO_PROXY environment does not include the minikube IP (192.168.49.2)</p></blockquote><p><img src="/../assets/kubernetes/SSjYbN4P1o6Tfjxkt1rcu0QlnJc.png"></p><p><img src="/../assets/kubernetes/IVp3b49qQofAPjxhH3bcxiBAnca.png"></p><ol><li>与集群交互通信</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get po -A<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/Wvfvb3LIXopxGNx2flEcpirznOb.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube dashboard --url<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/KL3sbKt4goqBQyxxwwUcljNmnJe.png"></p><ol><li>创建一个部署</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl create deployment hello-node --image=registry.k8s.io/e2e-test-images/agnhost:2.39 -- /agnhost netexec --http-port=8080<br><br>kubectl get deployments<br></code></pre></td></tr></table></figure><h2 id="kind"><a href="#kind" class="headerlink" title="kind"></a><a href="https://kind.sigs.k8s.io/docs/user/quick-start/#installing-from-release-binaries">kind</a></h2><ol><li>下载二进制包</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[ $(<span class="hljs-built_in">uname</span> -m) = x86_64 ] &amp;&amp; curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64<br><br>sudo <span class="hljs-built_in">chmod</span> +x ./kind<br>sudo <span class="hljs-built_in">mv</span> ./kind /usr/local/bin/<br></code></pre></td></tr></table></figure><ol><li><code>kind</code> 创建集群</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kind create cluster<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/TOHcb6YcXoebCAxsl5ScamFtnBe.png"></p><ol><li>观测集群</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl cluster-info --context kind-kind<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/N77UbZtNhoknHqxexaXc8TCSnSg.png"></p><ol><li>关闭集群</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kind delete cluster<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/JEuDbTnoRoQypnxdPJycNLlVn2g.png"></p><h2 id="通过-kubeadm-创建一个集群"><a href="#通过-kubeadm-创建一个集群" class="headerlink" title="通过 kubeadm 创建一个集群"></a><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/">通过</a> <code>kubeadm</code> <a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/">创建一个集群</a></h2><ul><li>资源需求<ul><li>一台以上能跑 deb&#x2F;rpm 包的 Linux 系统</li><li>2G 以上的 RAM 空闲</li><li>在任意一个控制结点上至少有 2 个 CPU</li><li>网络通畅的环境下</li></ul></li></ul><p><strong>部署流程</strong></p><ol><li>准备 hosts</li></ol><p>在所有的网络主机上安装容器运行时 <a href="https://yxrt3ryg3jg.feishu.cn/docx/Xru9d9V7MoSk5kxsFJXcqtUjn2c#MphRdOe5woWWRkxItl8c2fqrnHg">Kubernetes</a></p><ol><li>准备需要的容器镜像（可选）</li><li>初始化控制节点(control-plane node)</li></ol><p>控制结点意味着其是作为控制组件的机器运行的，其包括 <code>etcd</code>（集群数据库）以及 <code>API Server</code>（用于 <code>kubectl</code> 与集群的通信）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubeadm init<br></code></pre></td></tr></table></figure><h1 id="Kind"><a href="#Kind" class="headerlink" title="Kind"></a>Kind</h1><h2 id="在集群中加载镜像"><a href="#在集群中加载镜像" class="headerlink" title="在集群中加载镜像"></a>在集群中加载镜像</h2><p>在一个已经运行的集群中加载一个 <code>docker-image</code>，<code>dockerfile</code> 如下</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:latest<br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> <span class="hljs-variable">$&#123;pwd&#125;</span>/code /code</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt update &amp;&amp; apt install -y python3-pip &amp;&amp; apt-get clean</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip install flask</span><br><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [ <span class="hljs-string">&quot;sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;python3 /code/app.py&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><code>code</code> 里头运行了一个简单的 <code>flask</code> 应用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello_world</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;p&gt;Hello World!&lt;/p&gt;&quot;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app.run(host=<span class="hljs-string">&quot;0.0.0.0&quot;</span>,port=<span class="hljs-number">8080</span>,debug=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>加载到集群中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kind load docker-image flask-image:latest<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/O2hIbVjzkoI2bfxS3QVcdavHnAf.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it kind-control-plane crictl images<br></code></pre></td></tr></table></figure><p><img src="/../assets/kubernetes/TxjHbHJVsoPjNXxnIoLc8IuFnwc.png"></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="kubeadm-init"><a href="#kubeadm-init" class="headerlink" title="kubeadm init"></a><code>kubeadm init</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[WARNING Hostname]: hostname <span class="hljs-string">&quot;dydy-pc&quot;</span> could not be reached<br>[WARNING Hostname]: hostname <span class="hljs-string">&quot;dydy-pc&quot;</span>: lookup dydy-pc on 210.28.129.251:53: no such host<br></code></pre></td></tr></table></figure><p>修改 <code>/etc/hosts</code>，将 <code>localhost</code> 后面添加自己的电脑主机地址即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[ERROR CRI]: container runtime is not running: output: time=<span class="hljs-string">&quot;2023-09-19T09:03:23+08:00&quot;</span> level=fatal msg=<span class="hljs-string">&quot;validace connection: CRI v1 runtime API is not implemented for endpoint \&quot;unix:///var/run/containerd/containerd.sock\&quot;: rpc error: code = Unimplemented desc = unknown service runtime.v1.RuntimeService&quot;</span><br></code></pre></td></tr></table></figure><p><a href="https://yxrt3ryg3jg.feishu.cn/docx/Xru9d9V7MoSk5kxsFJXcqtUjn2c#part-RfVPd1aHPoNdExx7ppqcVT9Gn6f">Kubernetes 环境搭建</a></p><h2 id="kubeadm-config-images-pull"><a href="#kubeadm-config-images-pull" class="headerlink" title="kubeadm config images pull"></a><code>kubeadm config images pull</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">failed to pull image <span class="hljs-string">&quot;registry.k8s.io/kube-apiserver:v1.28.2&quot;</span>: output: E0919 09:32:01.239971   35982 remote_image.go:171] <span class="hljs-string">&quot;PullImage from image service failed&quot;</span> err=<span class="hljs-string">&quot;rpc error: code = Unavailable desc = connection error: desc = \&quot;transport: Error while dialing dial unix /var/run/containerd/containerd.sock: connect: permission denied\&quot;&quot;</span> image=<span class="hljs-string">&quot;registry.k8s.io/kube-apiserver:v1.28.2&quot;</span><br>time=<span class="hljs-string">&quot;2023-09-19T09:32:01+08:00&quot;</span> level=fatal msg=<span class="hljs-string">&quot;pulling image: rpc error: code = Unavailable desc = connection error: desc = \&quot;transport: Error while dialing dial unix /var/run/containerd/containerd.sock: connect: permission denied\&quot;&quot;</span><br>, error: <span class="hljs-built_in">exit</span> status 1<br></code></pre></td></tr></table></figure><p>生成默认配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubeadm config <span class="hljs-built_in">print</span> init-defaults &gt; init.default.yaml<br></code></pre></td></tr></table></figure><p>修改默认配置文件</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenWhisk 学习笔记</title>
    <link href="/2023/10/29/openwhisk/"/>
    <url>/2023/10/29/openwhisk/</url>
    
    <content type="html"><![CDATA[<h1 id="OpenWhisk概述"><a href="#OpenWhisk概述" class="headerlink" title="OpenWhisk概述"></a>OpenWhisk概述</h1><p>Openwhisk是属于Apache基金会的开源Faas计算平台，由IBM在2016年公布并贡献给开源社区。IBM Cloud本身也提供完全托管的OpenWhisk Faas服务IBM Cloud Function。从业务逻辑来看，OpenWhisk同AWS Lambda一样，为用户提供基于事件驱动的无状态的计算模型，并直接支持多种编程语言。</p><p>OpenWhisk特点：</p><ul><li>高性能，高扩展性的分布式FaaS计算平台</li><li>函数的代码及运行时全部在Docker容器中运行，利用Docker engine实现FaaS函数运行的管理、负载均衡、扩展.</li><li>OpenWhisk所有其他组件(如：API网关，控制器，触发器等)也全部运行在 Docker容器中。这使得OpenWhisk全栈可以很容易的部署在任意IaaS&#x2F;PaaS平台上。</li><li>相比其他FaaS实现(比如OpenFaaS)，OpenWhisk更像是一套完整的Serverless 解决方案，除了容器的调用和函数的管理，OpenWhisk 还包括了用户身份验证&#x2F;鉴权、函数异步触发等功能。</li></ul><p>目前支持的语言: <code>Nodejs</code>, <code>Python</code>, <code>Java</code>, <code>php</code>, <code>Ruby</code>, <code>Go</code>, <code>Rust</code>, <code>dotnet</code>, <code>Ballerina</code>, <code>blackBoxes</code>。</p><h1 id="OpenWhisk环境搭建"><a href="#OpenWhisk环境搭建" class="headerlink" title="OpenWhisk环境搭建"></a>OpenWhisk环境搭建</h1><h2 id="安装Java"><a href="#安装Java" class="headerlink" title="安装Java"></a>安装Java</h2><p>deepin上安装Java的方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install default-jre<br>sudo apt-get install default-jdk<br>安装nodejs<br><span class="hljs-comment">#下载Node.js安装包</span><br>wget https://nodejs.org/dist/v10.15.3/node-v10.15.3-linux-x64.tar.xz<br><span class="hljs-comment">#解压文件</span><br>tar xvf node-v10.15.3-linux-x64.tar.xz<br><span class="hljs-comment">#移动到相应目录下</span><br><span class="hljs-built_in">mv</span> ./node-v10.15.3-linux-x64 ./node<br><span class="hljs-built_in">mv</span> ./node /opt/node<br><span class="hljs-comment">#添加环境变量</span><br><span class="hljs-built_in">cd</span> <br>vim .bash_profile<br><span class="hljs-comment">#node</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/opt/node/bin<br></code></pre></td></tr></table></figure><h2 id="编译openwhisk"><a href="#编译openwhisk" class="headerlink" title="编译openwhisk"></a>编译openwhisk</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># git clone下来</span><br>git <span class="hljs-built_in">clone</span> https://github.com/apache/incubator-openwhisk.git openwhisk<br><span class="hljs-comment"># 切换到openwhisk目录，运行下面命令</span><br>$ ./gradlew :core:standalone:build<br></code></pre></td></tr></table></figure><p><img src="/../assets/openwhisk/o1.PNG"><br><img src="/../assets/openwhisk/o2.PNG"></p><h2 id="配置OpenWhisk-Cli工具"><a href="#配置OpenWhisk-Cli工具" class="headerlink" title="配置OpenWhisk Cli工具"></a>配置OpenWhisk Cli工具</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">- github下载网址：https://link.zhihu.com/?target=https%3A//github.com/apache/openwhisk-cli 下载二进制文件<br><span class="hljs-comment"># 上传到服务器解压, 解压</span><br><span class="hljs-comment"># 设置API HOST</span><br>wsk property <span class="hljs-built_in">set</span> --apihost http://172.17.0.1:3233<br><span class="hljs-comment"># 设置auth</span><br>wsk property <span class="hljs-built_in">set</span> --auth 789c46b1-71f6-4ed5-8c54-816aa4f8c502<br><span class="hljs-comment"># 可以通过以下命令获取当前的auth</span><br>wsk property get --auth<br></code></pre></td></tr></table></figure><p><img src="/../assets/openwhisk/o3.png"></p><h2 id="配置Docker"><a href="#配置Docker" class="headerlink" title="配置Docker"></a>配置Docker</h2><p><a href="https://cloud.tencent.com/developer/article/1753250">https://cloud.tencent.com/developer/article/1753250</a></p><ol><li>卸载旧版本残留</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get remove docker.io docker-engine<br></code></pre></td></tr></table></figure><ol start="2"><li>下载并安装密钥</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/debian/gpg | sudo apt-key add -<br></code></pre></td></tr></table></figure><ol start="3"><li>检查是否安装成功</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-key fingerprint 0EBFCD88<br></code></pre></td></tr></table></figure><p><img src="/../assets/openwhisk/o4.png"></p><ol start="4"><li>在source.list中添加docker-ce的软件源</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo deepin-editor /etc/apt/sources.list.d/docker.list <span class="hljs-comment"># 使用 deepin 默认的编辑器新建并打开 docker.list 文件</span><br><span class="hljs-comment"># 写入一条内容如下：</span><br>deb [<span class="hljs-built_in">arch</span>=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/debian buster stable <span class="hljs-comment"># 这里 buster 是 debain 版本的代号，deepin20 是debain10 代号为 buster，编辑完成后保存</span><br>注意： 使用 <span class="hljs-built_in">cat</span> /etc/debian_version 查看自己的 debain 版本。<br></code></pre></td></tr></table></figure><ol start="5"><li>更新仓库</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br></code></pre></td></tr></table></figure><ol start="6"><li>安装docker</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><ol start="7"><li>验证</li></ol><p><img src="/../assets/openwhisk/o5.png"><br><img src="/../assets/openwhisk/o6.png"></p><ol><li>管理启动项</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install chkconfig <br><span class="hljs-comment"># 列出所有启动项</span><br>sudo chkconfig<br><span class="hljs-comment"># chkconfig --help 查看帮助命令</span><br><br>sudo chkconfig --del docker<br></code></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>在openwhisk的bin目录下会有相应的可执行文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar openwhisk-standalone.jar<br></code></pre></td></tr></table></figure><p>如果docker需要管理员权限就加个sudo</p><p><img src="/../assets/openwhisk/o7.png"></p><p>服务起来后设置提示的命令:设置apihost和auth</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsk property <span class="hljs-built_in">set</span> --apihost <span class="hljs-string">&#x27;http://172.17.0.1:3233&#x27;</span> --auth <span class="hljs-string">&#x27;23bc46b1-71f6-4ed5-8c54-816aa4f8c502:123zO3xZCLrMN6v2BKK1dXYFpXlPkccOFqm12CdAsMgRU4VrNZ9lyGVCGuMDGIwP&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="/../assets/openwhisk/o8.png"><br><img src="/../assets/openwhisk/o9.png"></p><h1 id="OpenWhisk包下载"><a href="#OpenWhisk包下载" class="headerlink" title="OpenWhisk包下载"></a>OpenWhisk包下载</h1><h2 id="Catalog包"><a href="#Catalog包" class="headerlink" title="Catalog包"></a>Catalog包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/apache/openwhisk-catalog<br><span class="hljs-built_in">cd</span> openwhisk-catalog<br><span class="hljs-comment">#将一些变量添加进来</span><br>vim ~/.bashrc<br><br><span class="hljs-comment">#openwhisk</span><br>OPENWHISK_HOME=~/Serverless/openwhisk<br>WSK=<span class="hljs-variable">$OPENWHISK_HOME</span>/bin<br>CLI_PATH=<span class="hljs-variable">$OPENWHISK_HOME</span>/bin/wsk<br>API_HOST=http://172.17.0.1:3233<br>AUTH=789c46b1-71f6-4ed5-8c54-816aa4f8c502:abczO3xZCLrMN6v2BKK1dXYFpXlPkccOFqm12CdAsMgRU4VrNZ9lyGVCGuMDGIwP<br><span class="hljs-built_in">export</span> OPENWHISK_HOME CLI_PATH API_HOST API_KEY<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$WSK</span><br><br><br><span class="hljs-comment">#在本地standalone运行时下载包</span><br>./packages/installCatalogUsingWskdeploy.sh <span class="hljs-variable">$AUTH</span> <span class="hljs-variable">$API_HOST</span> <span class="hljs-variable">$CLI_PATH</span><br><span class="hljs-comment">#然后验证</span><br>wsk package list /whisk.system<br></code></pre></td></tr></table></figure><p><img src="/../assets/openwhisk/o10.png"></p><h1 id="OpenWhisk-couchDB数据库配置"><a href="#OpenWhisk-couchDB数据库配置" class="headerlink" title="OpenWhisk couchDB数据库配置"></a>OpenWhisk couchDB数据库配置</h1><ol><li>依次执行以下3条命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update &amp;&amp; sudo apt install -y curl apt-transport-https gnupg<br>curl https://couchdb.apache.org/repo/keys.asc | gpg --dearmor | sudo <span class="hljs-built_in">tee</span> /usr/share/keyrings/couchdb-archive-keyring.gpg &gt;/dev/null 2&gt;&amp;1source /etc/os-release<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb [signed-by=/usr/share/keyrings/couchdb-archive-keyring.gpg] https://apache.jfrog.io/artifactory/couchdb-deb/ <span class="hljs-variable">$&#123;VERSION_CODENAME&#125;</span> main&quot;</span> \| sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/couchdb.list &gt;/dev/null<br></code></pre></td></tr></table></figure><ol start="2"><li>执行后你可以在<code>/etc/apt/source.list.d</code>里头看到<code>couchdb.list</code>文件，用<code>vim</code>打开，将里头的<code>apricot</code>改为<code>buster</code>，因为原来那个在网站上的资源没有了T_T</li><li>之后更新源后下载couchdb</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br>sudo apt install couchdb<br></code></pre></td></tr></table></figure><ol start="4"><li>新建一个文件夹后在里头导出一些环境变量</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> logconf &amp;&amp; <span class="hljs-built_in">cd</span> logconf<br>vim wsk_env.sh<br><span class="hljs-built_in">export</span> OW_DB=CouchDB<br><span class="hljs-built_in">export</span> OW_DB_USERNAME=openwhisk<br><span class="hljs-built_in">export</span> OW_DB_PASSWORD=openwhisk<br><span class="hljs-built_in">export</span> OW_DB_PROTOCOL=http<br><span class="hljs-built_in">export</span> OW_DB_HOST=127.0.0.1<br><span class="hljs-built_in">export</span> OW_DB_PORT=4444<br><span class="hljs-built_in">export</span> OPENWHISK_TMP_DIR=~/Serverles/logconf<br></code></pre></td></tr></table></figure><ol start="5"><li>之后进行ansible安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> openwsk_env.sh<br><span class="hljs-built_in">cd</span> ansible<br>ansible-playbook -i environments/local setup.yml<br></code></pre></td></tr></table></figure><p><img src="/../assets/openwhisk/o11.png"></p><p><img src="/../assets/openwhisk/o12.png"></p><h1 id="OpenWhisk内部流程"><a href="#OpenWhisk内部流程" class="headerlink" title="OpenWhisk内部流程"></a>OpenWhisk内部流程</h1><p><img src="/../assets/openwhisk/o13.png"></p><ol><li>面向用户的REST API(Nginx)：OpenWhisk通过Nginx 接收函数触发和函数的CRUD请求。</li><li>控制器(Controller): 真正处理请求的地方。</li><li>CouchDB(身份验证和鉴权):控制器首先需要验证用户的身份和权限。用户的身份信息保存在CouchDB的用户身份数据库中。验证无误后，控制器进行下一步处理。</li><li>CouchDB: 确认用户的身份后，控制器需要从 CouchDB中读取将要被触发的action。action对应的数据存储在CouchDB的whisk 数据库，主要包含要被执行的代码、默认参数、被执行代码的权限等。</li><li>Consul和负载均衡:控制器已经有了触发函数所需要的全部信息，在将数据发送给触发器(Invoker)之前，控制器需要和Consul确认，从Consul 获取处于空闲状态的触发器的地址。Consul 是一个开源的服务注册&#x2F;发现系统，在 OpenWhisk中Consul负责记录跟踪所有触发器的状态信息。当控制器向Consul发出请求，Consul从后台随机选取一个空闲的触发器信息，并返回。</li><li>触发请求送进Kafka: Kafka 充当了Controller和Invoker之间的缓存，当后端 Invoker 负载过大，没有及时处理Kafka数据流中的请求时，Controller 依然可以将请求送入Kafka，无需阻塞当前线程。同时所有送进Kafka 的请求消息都会被以log的形式的形式保存在文件系统中，即使系统瘫痪，已经由 Controller发出的请求也不会丢失。</li><li>触发器运行用户代码: 触发器从对应的 Kafka topic 中接收控制器传来的请求，并执行响应代码。OpenWhisk 的触发器是构建在 Docker 之上的，每一个函数触发都运行在一个独立的 Docker 容器之内.</li><li>CouchDB 保存运行结果: 触发器执行结果最终会被保存在 CouchDB 中的 whisk 数据库里</li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/weixin_51971301/article/details/121436849">openwhisk配置流程</a><br><a href="https://mlog.club/article/5772204">bbs-go-site</a><br><a href="https://docs.couchdb.org/en/latest/install/unix.html#installation-using-the-apache-couchdb-convenience-binary-packages">1.1. Installation on Unix-like systems ‒ Apache CouchDB® 3.2 Documentation</a></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenWhisk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>300 days</title>
    <link href="/2023/10/28/300days/"/>
    <url>/2023/10/28/300days/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="请不要打扰他人的恋爱生活哦" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="f6b593e14d38d80b0d7fd9aa653f7924ca3c57b2bd429d02e9805f0882492418">1194fa21f186a33598eeef1a2c722f320d12645adf4fd723ac07a85c8e240c4d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Enter to get the 300 days surprise</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>恋爱</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker 笔记</title>
    <link href="/2023/10/28/docker/"/>
    <url>/2023/10/28/docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p>卸载旧版本残留</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get remove docker.io docker-engine<br></code></pre></td></tr></table></figure><ol><li>下载并安装密钥</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/debian/gpg | sudo apt-key add -<br></code></pre></td></tr></table></figure><ol start="2"><li>检查是否安装成功</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-key fingerprint 0EBFCD88<br></code></pre></td></tr></table></figure><p><img src="/../assets/docker/docker1.PNG"></p><ol start="3"><li>在source.list中添加docker-ce的软件源</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo deepin-editor /etc/apt/sources.list.d/docker.list <span class="hljs-comment"># 使用 deepin 默认的编辑器新建并打开 docker.list 文件</span><br><span class="hljs-comment"># 写入一条内容如下：</span><br>deb [<span class="hljs-built_in">arch</span>=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/debian buster stable <span class="hljs-comment"># 这里 buster 是 debain 版本的代号，deepin20 是debain10 代号为 buster，编辑完成后保存</span><br></code></pre></td></tr></table></figure><p>注意： 使用 cat &#x2F;etc&#x2F;debian_version 查看自己的 debain 版本。</p><ol start="4"><li>更新仓库</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br></code></pre></td></tr></table></figure><ol start="5"><li>安装docker</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><ol start="6"><li><p>验证<br><img src="/../assets/docker/docker2.PNG"></p></li><li><p>管理启动项</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install chkconfig <br><span class="hljs-comment"># 列出所有启动项</span><br>sudo chkconfig<br><span class="hljs-comment"># chkconfig --help 查看帮助命令</span><br><br>sudo chkconfig --del docker<br></code></pre></td></tr></table></figure><ol start="8"><li>Rootless 配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo usermod -aG docker <span class="hljs-variable">$USER</span><br>reboot<br></code></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="拷贝文件夹"><a href="#拷贝文件夹" class="headerlink" title="拷贝文件夹"></a>拷贝文件夹</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> &lt;container&gt;:&lt;container-dir&gt; &lt;local-dir&gt;<br></code></pre></td></tr></table></figure><h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><h2 id="环境安装-1"><a href="#环境安装-1" class="headerlink" title="环境安装"></a>环境安装</h2><ol><li>下载二进制包</li></ol><p><a href="https://github.com/docker/compose/releases">https://github.com/docker/compose/releases</a></p><ol start="2"><li>添加权限并移动到&#x2F;usr&#x2F;local&#x2F;bin下</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chmod</span> 755 docker-compose-linux-x86_64<br>sudo <span class="hljs-built_in">mv</span> docker-compose-linux-x86_64 /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><ol start="3"><li>验证</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose<br></code></pre></td></tr></table></figure><p><img src="/../assets/docker/docker3.png"></p><h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><h3 id="1-定义应用依赖"><a href="#1-定义应用依赖" class="headerlink" title="1. 定义应用依赖"></a>1. 定义应用依赖</h3><p>使用一个简单的程序</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">import</span> redis<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br>app = Flask(__name__)<br>cache = redis.Redis(host=<span class="hljs-string">&#x27;redis&#x27;</span>, port=<span class="hljs-number">6379</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_hit_count</span>():<br>    retries = <span class="hljs-number">5</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> cache.incr(<span class="hljs-string">&#x27;hits&#x27;</span>)<br>        <span class="hljs-keyword">except</span> redis.exceptions.ConnectionError <span class="hljs-keyword">as</span> exc:<br>            <span class="hljs-keyword">if</span> retries == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">raise</span> exc<br>            retries -= <span class="hljs-number">1</span><br>            time.sleep(<span class="hljs-number">0.5</span>)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():<br>    count = get_hit_count()<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello World! I have been seen &#123;&#125; times.\n&#x27;</span>.<span class="hljs-built_in">format</span>(count)<br></code></pre></td></tr></table></figure><p>并提供其软件包<code>requirements.txt</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">flask<br>redis<br></code></pre></td></tr></table></figure><h3 id="2-定义一个Dockerfile"><a href="#2-定义一个Dockerfile" class="headerlink" title="2. 定义一个Dockerfile"></a>2. 定义一个Dockerfile</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># syntax=docker/dockerfile:1</span><br><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.7</span>-alpine<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /code</span><br><span class="hljs-keyword">ENV</span> FLASK_APP=app.py<br><span class="hljs-keyword">ENV</span> FLASK_RUN_HOST=<span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apk add --no-cache gcc musl-dev linux-headers</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> requirements.txt requirements.txt</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">5000</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;flask&quot;</span>, <span class="hljs-string">&quot;run&quot;</span>]</span><br></code></pre></td></tr></table></figure><h3 id="3-定义一个compose文件"><a href="#3-定义一个compose文件" class="headerlink" title="3. 定义一个compose文件"></a>3. 定义一个compose文件</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">services:<br>  web:<br>    build: .<br>    ports:<br>      - <span class="hljs-string">&quot;8000:5000&quot;</span><br>  redis:<br>    image: <span class="hljs-string">&quot;redis:alpine&quot;</span><br></code></pre></td></tr></table></figure><h3 id="4-构建运行"><a href="#4-构建运行" class="headerlink" title="4. 构建运行"></a>4. 构建运行</h3><p>运行<code>docker compose up</code></p><p><img src="/../assets/docker/docker4.png"><br><img src="/../assets/docker/docker5.png"><br>停止运行<code>docker compose down</code></p><h3 id="5-compose文件添加挂载"><a href="#5-compose文件添加挂载" class="headerlink" title="5. compose文件添加挂载"></a>5. compose文件添加挂载</h3><p>重新编辑一下compose文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">services:<br>  web:<br>    build: .<br>    ports:<br>      - <span class="hljs-string">&quot;8000:5000&quot;</span><br>    volumes:<br>      - .:/code<br>    environment:<br>      FLASK_DEBUG: <span class="hljs-string">&quot;true&quot;</span><br>  redis:<br>    image: <span class="hljs-string">&quot;redis:alpine&quot;</span><br></code></pre></td></tr></table></figure><h3 id="6-重新构建"><a href="#6-重新构建" class="headerlink" title="6. 重新构建"></a>6. 重新构建</h3><p><img src="/../assets/docker/docker6.png"></p><h3 id="7-应用更新"><a href="#7-应用更新" class="headerlink" title="7. 应用更新"></a>7. 应用更新</h3><p>由于在上面的步骤中，我们将应用程序的代码与容器进行挂载，因此，当我们现在对源代码进行修改时，容器里头的代码也会跟着修改</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello from Docker! I have been seen &#123;&#125; times.\n&#x27;</span>.<span class="hljs-built_in">format</span>(count)<br></code></pre></td></tr></table></figure><p><img src="/../assets/docker/docker7.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/10/22/hello-world/"/>
    <url>/2023/10/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
